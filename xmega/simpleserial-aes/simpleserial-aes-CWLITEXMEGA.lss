
simpleserial-aes-CWLITEXMEGA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000dc2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000021c  00802000  00000dc2  00000e56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000001b6  0080221c  0080221c  00001072  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00001072  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001084  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000108  00000000  00000000  000010c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004487  00000000  00000000  000011cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c0e  00000000  00000000  00005653  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000e01  00000000  00000000  00008261  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005b0  00000000  00000000  00009064  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000207b  00000000  00000000  00009614  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000015d6  00000000  00000000  0000b68f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  0000cc65  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 f0 00 	jmp	0x1e0	; 0x1e0 <__ctors_end>
   4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
   8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
   c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  10:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  14:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  18:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  1c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  20:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  24:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  28:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  2c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  30:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  34:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  38:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  3c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  40:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  44:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  48:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  4c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  50:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  54:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  58:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  5c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  60:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  64:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  68:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  6c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  70:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  74:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  78:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  7c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  80:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  84:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  88:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  8c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  90:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  94:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  98:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  9c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  a0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  a4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  a8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  ac:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  b0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  b4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  b8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  bc:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  c0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  c4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  c8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  cc:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  d0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  d4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  d8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  dc:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  e0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  e4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  e8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  ec:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  f0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  f4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  f8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
  fc:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 100:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 104:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 108:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 10c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 110:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 114:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 118:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 11c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 120:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 124:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 128:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 12c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 130:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 134:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 138:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 13c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 140:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 144:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 148:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 14c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 150:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 154:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 158:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 15c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 160:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 164:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 168:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 16c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 170:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 174:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 178:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 17c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 180:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 184:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 188:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 18c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 190:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 194:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 198:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 19c:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1a0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1a4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1a8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1ac:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1b0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1b4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1b8:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1bc:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1c0:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>
 1c4:	0c 94 11 01 	jmp	0x222	; 0x222 <__bad_interrupt>

000001c8 <__trampolines_start>:
 1c8:	0c 94 40 01 	jmp	0x280	; 0x280 <check_version>
 1cc:	0c 94 17 02 	jmp	0x42e	; 0x42e <ss_num_commands>
 1d0:	0c 94 2b 02 	jmp	0x456	; 0x456 <ss_get_commands>
 1d4:	0c 94 13 01 	jmp	0x226	; 0x226 <handle_echo>
 1d8:	0c 94 27 01 	jmp	0x24e	; 0x24e <handle_pt>
 1dc:	0c 94 19 01 	jmp	0x232	; 0x232 <handle_key>

000001e0 <__ctors_end>:
 1e0:	11 24       	eor	r1, r1
 1e2:	1f be       	out	0x3f, r1	; 63
 1e4:	cf ef       	ldi	r28, 0xFF	; 255
 1e6:	cd bf       	out	0x3d, r28	; 61
 1e8:	df e3       	ldi	r29, 0x3F	; 63
 1ea:	de bf       	out	0x3e, r29	; 62
 1ec:	00 e0       	ldi	r16, 0x00	; 0
 1ee:	0c bf       	out	0x3c, r16	; 60

000001f0 <__do_copy_data>:
 1f0:	12 e2       	ldi	r17, 0x22	; 34
 1f2:	a0 e0       	ldi	r26, 0x00	; 0
 1f4:	b0 e2       	ldi	r27, 0x20	; 32
 1f6:	e2 ec       	ldi	r30, 0xC2	; 194
 1f8:	fd e0       	ldi	r31, 0x0D	; 13
 1fa:	00 e0       	ldi	r16, 0x00	; 0
 1fc:	0b bf       	out	0x3b, r16	; 59
 1fe:	02 c0       	rjmp	.+4      	; 0x204 <__do_copy_data+0x14>
 200:	07 90       	elpm	r0, Z+
 202:	0d 92       	st	X+, r0
 204:	ac 31       	cpi	r26, 0x1C	; 28
 206:	b1 07       	cpc	r27, r17
 208:	d9 f7       	brne	.-10     	; 0x200 <__do_copy_data+0x10>

0000020a <__do_clear_bss>:
 20a:	23 e2       	ldi	r18, 0x23	; 35
 20c:	ac e1       	ldi	r26, 0x1C	; 28
 20e:	b2 e2       	ldi	r27, 0x22	; 34
 210:	01 c0       	rjmp	.+2      	; 0x214 <.do_clear_bss_start>

00000212 <.do_clear_bss_loop>:
 212:	1d 92       	st	X+, r1

00000214 <.do_clear_bss_start>:
 214:	a2 3d       	cpi	r26, 0xD2	; 210
 216:	b2 07       	cpc	r27, r18
 218:	e1 f7       	brne	.-8      	; 0x212 <.do_clear_bss_loop>
 21a:	0e 94 be 06 	call	0xd7c	; 0xd7c <main>
 21e:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <_exit>

00000222 <__bad_interrupt>:
 222:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000226 <handle_echo>:
    simpleserial_put('r', 16, out);
    return 0x00;
}

uint8_t handle_echo(uint8_t *in, uint8_t len){
    simpleserial_put('t', len, in);
 226:	ac 01       	movw	r20, r24
 228:	84 e7       	ldi	r24, 0x74	; 116
 22a:	0e 94 d6 01 	call	0x3ac	; 0x3ac <simpleserial_put>
    return 0x00;
}
 22e:	80 e0       	ldi	r24, 0x00	; 0
 230:	08 95       	ret

00000232 <handle_key>:
#include <string.h>

static uint8_t key[16];
static uint8_t out[16];

uint8_t handle_key(uint8_t *k, uint8_t len){
 232:	fc 01       	movw	r30, r24
    if(len != 16) return 0x01;
 234:	60 31       	cpi	r22, 0x10	; 16
 236:	49 f4       	brne	.+18     	; 0x24a <handle_key+0x18>
    memcpy(key, k, 16);
 238:	90 e1       	ldi	r25, 0x10	; 16
 23a:	ac e2       	ldi	r26, 0x2C	; 44
 23c:	b2 e2       	ldi	r27, 0x22	; 34
 23e:	01 90       	ld	r0, Z+
 240:	0d 92       	st	X+, r0
 242:	9a 95       	dec	r25
 244:	e1 f7       	brne	.-8      	; 0x23e <handle_key+0xc>
 246:	80 e0       	ldi	r24, 0x00	; 0
 248:	08 95       	ret

static uint8_t key[16];
static uint8_t out[16];

uint8_t handle_key(uint8_t *k, uint8_t len){
    if(len != 16) return 0x01;
 24a:	81 e0       	ldi	r24, 0x01	; 1
    memcpy(key, k, 16);
    return 0x00;
}
 24c:	08 95       	ret

0000024e <handle_pt>:

uint8_t handle_pt(uint8_t *pt, uint8_t len){
 24e:	cf 93       	push	r28
    if(len != 16) return 0x01;
 250:	60 31       	cpi	r22, 0x10	; 16
 252:	99 f4       	brne	.+38     	; 0x27a <handle_pt+0x2c>
    trigger_high();
 254:	c1 e0       	ldi	r28, 0x01	; 1
 256:	c0 93 05 06 	sts	0x0605, r28	; 0x800605 <__TEXT_REGION_LENGTH__+0x7de605>
    AES128_ECB_encrypt(pt, key, out);
 25a:	4c e1       	ldi	r20, 0x1C	; 28
 25c:	52 e2       	ldi	r21, 0x22	; 34
 25e:	6c e2       	ldi	r22, 0x2C	; 44
 260:	72 e2       	ldi	r23, 0x22	; 34
 262:	0e 94 d5 05 	call	0xbaa	; 0xbaa <AES128_ECB_encrypt>
    trigger_low();
 266:	c0 93 06 06 	sts	0x0606, r28	; 0x800606 <__TEXT_REGION_LENGTH__+0x7de606>
    simpleserial_put('r', 16, out);
 26a:	4c e1       	ldi	r20, 0x1C	; 28
 26c:	52 e2       	ldi	r21, 0x22	; 34
 26e:	60 e1       	ldi	r22, 0x10	; 16
 270:	82 e7       	ldi	r24, 0x72	; 114
 272:	0e 94 d6 01 	call	0x3ac	; 0x3ac <simpleserial_put>
 276:	80 e0       	ldi	r24, 0x00	; 0
 278:	01 c0       	rjmp	.+2      	; 0x27c <handle_pt+0x2e>
    memcpy(key, k, 16);
    return 0x00;
}

uint8_t handle_pt(uint8_t *pt, uint8_t len){
    if(len != 16) return 0x01;
 27a:	81 e0       	ldi	r24, 0x01	; 1
    trigger_high();
    AES128_ECB_encrypt(pt, key, out);
    trigger_low();
    simpleserial_put('r', 16, out);
    return 0x00;
}
 27c:	cf 91       	pop	r28
 27e:	08 95       	ret

00000280 <check_version>:
// Callback function for "v" command.
// This can exist in v1.0 as long as we don't actually send back an ack ("z")
uint8_t check_version(uint8_t *v, uint8_t len)
{
	return SS_VER;
}
 280:	81 e0       	ldi	r24, 0x01	; 1
 282:	08 95       	ret

00000284 <ss_crc>:


// 0xA6 formerly 
#define CW_CRC 0x4D 
uint8_t ss_crc(uint8_t *buf, uint8_t len)
{
 284:	fc 01       	movw	r30, r24
	unsigned int k = 0;
	uint8_t crc = 0x00;
 286:	80 e0       	ldi	r24, 0x00	; 0
	while (len--) {
		crc ^= *buf++;
		for (k = 0; k < 8; k++) {
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 288:	9d e4       	ldi	r25, 0x4D	; 77
#define CW_CRC 0x4D 
uint8_t ss_crc(uint8_t *buf, uint8_t len)
{
	unsigned int k = 0;
	uint8_t crc = 0x00;
	while (len--) {
 28a:	61 50       	subi	r22, 0x01	; 1
 28c:	70 f0       	brcs	.+28     	; 0x2aa <ss_crc+0x26>
		crc ^= *buf++;
 28e:	21 91       	ld	r18, Z+
 290:	82 27       	eor	r24, r18
 292:	28 e0       	ldi	r18, 0x08	; 8
 294:	30 e0       	ldi	r19, 0x00	; 0
		for (k = 0; k < 8; k++) {
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
 296:	87 ff       	sbrs	r24, 7
 298:	03 c0       	rjmp	.+6      	; 0x2a0 <ss_crc+0x1c>
 29a:	88 0f       	add	r24, r24
 29c:	89 27       	eor	r24, r25
 29e:	01 c0       	rjmp	.+2      	; 0x2a2 <ss_crc+0x1e>
 2a0:	88 0f       	add	r24, r24
 2a2:	21 50       	subi	r18, 0x01	; 1
 2a4:	31 09       	sbc	r19, r1
{
	unsigned int k = 0;
	uint8_t crc = 0x00;
	while (len--) {
		crc ^= *buf++;
		for (k = 0; k < 8; k++) {
 2a6:	b9 f7       	brne	.-18     	; 0x296 <ss_crc+0x12>
 2a8:	f0 cf       	rjmp	.-32     	; 0x28a <ss_crc+0x6>
			crc = crc & 0x80 ? (crc << 1) ^ CW_CRC: crc << 1;
		}
	}
	return crc;

}
 2aa:	08 95       	ret

000002ac <hex_decode>:
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

int hex_decode(int len, char* ascii_buf, uint8_t* data_buf)
{
 2ac:	db 01       	movw	r26, r22
	for(int i = 0; i < len; i++)
 2ae:	fa 01       	movw	r30, r20
 2b0:	9f 01       	movw	r18, r30
 2b2:	24 1b       	sub	r18, r20
 2b4:	35 0b       	sbc	r19, r21
 2b6:	28 17       	cp	r18, r24
 2b8:	39 07       	cpc	r19, r25
 2ba:	d4 f5       	brge	.+116    	; 0x330 <hex_decode+0x84>
	{
		char n_hi = ascii_buf[2*i];
 2bc:	2c 91       	ld	r18, X
		char n_lo = ascii_buf[2*i+1];
 2be:	11 96       	adiw	r26, 0x01	; 1
 2c0:	3c 91       	ld	r19, X
 2c2:	11 97       	sbiw	r26, 0x01	; 1

		if(n_lo >= '0' && n_lo <= '9')
 2c4:	60 ed       	ldi	r22, 0xD0	; 208
 2c6:	63 0f       	add	r22, r19
 2c8:	6a 30       	cpi	r22, 0x0A	; 10
 2ca:	10 f4       	brcc	.+4      	; 0x2d0 <hex_decode+0x24>
			data_buf[i] = n_lo - '0';
 2cc:	60 83       	st	Z, r22
 2ce:	0f c0       	rjmp	.+30     	; 0x2ee <hex_decode+0x42>
		else if(n_lo >= 'A' && n_lo <= 'F')
 2d0:	6f eb       	ldi	r22, 0xBF	; 191
 2d2:	63 0f       	add	r22, r19
 2d4:	66 30       	cpi	r22, 0x06	; 6
 2d6:	10 f4       	brcc	.+4      	; 0x2dc <hex_decode+0x30>
			data_buf[i] = n_lo - 'A' + 10;
 2d8:	37 53       	subi	r19, 0x37	; 55
 2da:	08 c0       	rjmp	.+16     	; 0x2ec <hex_decode+0x40>
		else if(n_lo >= 'a' && n_lo <= 'f')
 2dc:	6f e9       	ldi	r22, 0x9F	; 159
 2de:	63 0f       	add	r22, r19
 2e0:	66 30       	cpi	r22, 0x06	; 6
 2e2:	18 f0       	brcs	.+6      	; 0x2ea <hex_decode+0x3e>
			data_buf[i] = n_lo - 'a' + 10;
		else
			return 1;
 2e4:	81 e0       	ldi	r24, 0x01	; 1
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	08 95       	ret
		if(n_lo >= '0' && n_lo <= '9')
			data_buf[i] = n_lo - '0';
		else if(n_lo >= 'A' && n_lo <= 'F')
			data_buf[i] = n_lo - 'A' + 10;
		else if(n_lo >= 'a' && n_lo <= 'f')
			data_buf[i] = n_lo - 'a' + 10;
 2ea:	37 55       	subi	r19, 0x57	; 87
 2ec:	30 83       	st	Z, r19
		else
			return 1;

		if(n_hi >= '0' && n_hi <= '9')
 2ee:	30 ed       	ldi	r19, 0xD0	; 208
 2f0:	32 0f       	add	r19, r18
 2f2:	3a 30       	cpi	r19, 0x0A	; 10
 2f4:	18 f4       	brcc	.+6      	; 0x2fc <hex_decode+0x50>
			data_buf[i] |= (n_hi - '0') << 4;
 2f6:	22 95       	swap	r18
 2f8:	20 7f       	andi	r18, 0xF0	; 240
 2fa:	14 c0       	rjmp	.+40     	; 0x324 <hex_decode+0x78>
		else if(n_hi >= 'A' && n_hi <= 'F')
 2fc:	3f eb       	ldi	r19, 0xBF	; 191
 2fe:	32 0f       	add	r19, r18
 300:	36 30       	cpi	r19, 0x06	; 6
 302:	20 f4       	brcc	.+8      	; 0x30c <hex_decode+0x60>
			data_buf[i] |= (n_hi - 'A' + 10) << 4;
 304:	30 e0       	ldi	r19, 0x00	; 0
 306:	27 53       	subi	r18, 0x37	; 55
 308:	31 09       	sbc	r19, r1
 30a:	07 c0       	rjmp	.+14     	; 0x31a <hex_decode+0x6e>
		else if(n_hi >= 'a' && n_hi <= 'f')
 30c:	3f e9       	ldi	r19, 0x9F	; 159
 30e:	32 0f       	add	r19, r18
 310:	36 30       	cpi	r19, 0x06	; 6
 312:	40 f7       	brcc	.-48     	; 0x2e4 <hex_decode+0x38>
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
 314:	30 e0       	ldi	r19, 0x00	; 0
 316:	27 55       	subi	r18, 0x57	; 87
 318:	31 09       	sbc	r19, r1
 31a:	64 e0       	ldi	r22, 0x04	; 4
 31c:	22 0f       	add	r18, r18
 31e:	33 1f       	adc	r19, r19
 320:	6a 95       	dec	r22
 322:	e1 f7       	brne	.-8      	; 0x31c <hex_decode+0x70>
 324:	30 81       	ld	r19, Z
 326:	23 2b       	or	r18, r19
 328:	20 83       	st	Z, r18
 32a:	31 96       	adiw	r30, 0x01	; 1
 32c:	12 96       	adiw	r26, 0x02	; 2
 32e:	c0 cf       	rjmp	.-128    	; 0x2b0 <hex_decode+0x4>
		else
			return 1;
	}

	return 0;
 330:	80 e0       	ldi	r24, 0x00	; 0
 332:	90 e0       	ldi	r25, 0x00	; 0
}
 334:	08 95       	ret

00000336 <simpleserial_addcmd_flags>:
	return simpleserial_addcmd_flags(c, len, fp, CMD_FLAG_NONE);
}

int simpleserial_addcmd_flags(char c, unsigned int len, uint8_t (*fp)(uint8_t*, uint8_t), uint8_t fl)
{
	if(num_commands >= MAX_SS_CMDS)
 336:	a0 91 fc 22 	lds	r26, 0x22FC	; 0x8022fc <num_commands>
 33a:	b0 91 fd 22 	lds	r27, 0x22FD	; 0x8022fd <num_commands+0x1>
 33e:	a0 32       	cpi	r26, 0x20	; 32
 340:	b1 05       	cpc	r27, r1
 342:	cc f4       	brge	.+50     	; 0x376 <simpleserial_addcmd_flags+0x40>
		return 1;

	if(len >= MAX_SS_LEN)
 344:	60 34       	cpi	r22, 0x40	; 64
 346:	71 05       	cpc	r23, r1
 348:	b0 f4       	brcc	.+44     	; 0x376 <simpleserial_addcmd_flags+0x40>
		return 1;

	commands[num_commands].c   = c;
 34a:	96 e0       	ldi	r25, 0x06	; 6
 34c:	9a 9f       	mul	r25, r26
 34e:	f0 01       	movw	r30, r0
 350:	9b 9f       	mul	r25, r27
 352:	f0 0d       	add	r31, r0
 354:	11 24       	eor	r1, r1
 356:	e4 5c       	subi	r30, 0xC4	; 196
 358:	fd 4d       	sbci	r31, 0xDD	; 221
 35a:	80 83       	st	Z, r24
	commands[num_commands].len = len;
 35c:	61 83       	std	Z+1, r22	; 0x01
 35e:	72 83       	std	Z+2, r23	; 0x02
	commands[num_commands].fp  = fp;
 360:	43 83       	std	Z+3, r20	; 0x03
 362:	54 83       	std	Z+4, r21	; 0x04
	commands[num_commands].flags = fl;
 364:	25 83       	std	Z+5, r18	; 0x05
	num_commands++;
 366:	11 96       	adiw	r26, 0x01	; 1
 368:	a0 93 fc 22 	sts	0x22FC, r26	; 0x8022fc <num_commands>
 36c:	b0 93 fd 22 	sts	0x22FD, r27	; 0x8022fd <num_commands+0x1>

	return 0;
 370:	80 e0       	ldi	r24, 0x00	; 0
 372:	90 e0       	ldi	r25, 0x00	; 0
 374:	08 95       	ret
}

int simpleserial_addcmd_flags(char c, unsigned int len, uint8_t (*fp)(uint8_t*, uint8_t), uint8_t fl)
{
	if(num_commands >= MAX_SS_CMDS)
		return 1;
 376:	81 e0       	ldi	r24, 0x01	; 1
 378:	90 e0       	ldi	r25, 0x00	; 0
	commands[num_commands].fp  = fp;
	commands[num_commands].flags = fl;
	num_commands++;

	return 0;
}
 37a:	08 95       	ret

0000037c <simpleserial_addcmd>:
    simpleserial_addcmd('y', 0, ss_num_commands);
}

int simpleserial_addcmd(char c, unsigned int len, uint8_t (*fp)(uint8_t*, uint8_t))
{
	return simpleserial_addcmd_flags(c, len, fp, CMD_FLAG_NONE);
 37c:	20 e0       	ldi	r18, 0x00	; 0
 37e:	0c 94 9b 01 	jmp	0x336	; 0x336 <simpleserial_addcmd_flags>

00000382 <simpleserial_init>:

// Set up the SimpleSerial module by preparing internal commands
// This just adds the "v" command for now...
void simpleserial_init()
{
	simpleserial_addcmd('v', 0, check_version);
 382:	40 e4       	ldi	r20, 0x40	; 64
 384:	51 e0       	ldi	r21, 0x01	; 1
 386:	60 e0       	ldi	r22, 0x00	; 0
 388:	70 e0       	ldi	r23, 0x00	; 0
 38a:	86 e7       	ldi	r24, 0x76	; 118
 38c:	0e 94 be 01 	call	0x37c	; 0x37c <simpleserial_addcmd>
    simpleserial_addcmd('w', 0, ss_get_commands);
 390:	4b e2       	ldi	r20, 0x2B	; 43
 392:	52 e0       	ldi	r21, 0x02	; 2
 394:	60 e0       	ldi	r22, 0x00	; 0
 396:	70 e0       	ldi	r23, 0x00	; 0
 398:	87 e7       	ldi	r24, 0x77	; 119
 39a:	0e 94 be 01 	call	0x37c	; 0x37c <simpleserial_addcmd>
    simpleserial_addcmd('y', 0, ss_num_commands);
 39e:	47 e1       	ldi	r20, 0x17	; 23
 3a0:	52 e0       	ldi	r21, 0x02	; 2
 3a2:	60 e0       	ldi	r22, 0x00	; 0
 3a4:	70 e0       	ldi	r23, 0x00	; 0
 3a6:	89 e7       	ldi	r24, 0x79	; 121
 3a8:	0c 94 be 01 	jmp	0x37c	; 0x37c <simpleserial_addcmd>

000003ac <simpleserial_put>:
	simpleserial_put('z', 1, ret);
#endif
}

void simpleserial_put(char c, uint8_t size, uint8_t* output)
{
 3ac:	cf 92       	push	r12
 3ae:	df 92       	push	r13
 3b0:	ef 92       	push	r14
 3b2:	ff 92       	push	r15
 3b4:	0f 93       	push	r16
 3b6:	1f 93       	push	r17
 3b8:	cf 93       	push	r28
 3ba:	df 93       	push	r29
	// Write first character
    if (!output) return;
 3bc:	41 15       	cp	r20, r1
 3be:	51 05       	cpc	r21, r1
 3c0:	69 f1       	breq	.+90     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
 3c2:	8a 01       	movw	r16, r20
 3c4:	c6 2f       	mov	r28, r22
	putch(c);
 3c6:	0e 94 70 03 	call	0x6e0	; 0x6e0 <output_ch_0>
 3ca:	78 01       	movw	r14, r16

	// Write each byte as two nibbles
	for(int i = 0; i < size; i++)
 3cc:	d0 e0       	ldi	r29, 0x00	; 0
 3ce:	c7 01       	movw	r24, r14
 3d0:	80 1b       	sub	r24, r16
 3d2:	91 0b       	sbc	r25, r17
 3d4:	8c 17       	cp	r24, r28
 3d6:	9d 07       	cpc	r25, r29
 3d8:	b4 f4       	brge	.+44     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
 3da:	67 01       	movw	r12, r14
	{
		putch(hex_lookup[output[i] >> 4 ]);
 3dc:	d7 01       	movw	r26, r14
 3de:	ed 91       	ld	r30, X+
 3e0:	7d 01       	movw	r14, r26
 3e2:	e2 95       	swap	r30
 3e4:	ef 70       	andi	r30, 0x0F	; 15
 3e6:	f0 e0       	ldi	r31, 0x00	; 0
 3e8:	e5 5f       	subi	r30, 0xF5	; 245
 3ea:	fd 4d       	sbci	r31, 0xDD	; 221
 3ec:	80 81       	ld	r24, Z
 3ee:	0e 94 70 03 	call	0x6e0	; 0x6e0 <output_ch_0>
		putch(hex_lookup[output[i] & 0xF]);
 3f2:	d6 01       	movw	r26, r12
 3f4:	ec 91       	ld	r30, X
 3f6:	ef 70       	andi	r30, 0x0F	; 15
 3f8:	f0 e0       	ldi	r31, 0x00	; 0
 3fa:	e5 5f       	subi	r30, 0xF5	; 245
 3fc:	fd 4d       	sbci	r31, 0xDD	; 221
 3fe:	80 81       	ld	r24, Z
 400:	0e 94 70 03 	call	0x6e0	; 0x6e0 <output_ch_0>
 404:	e4 cf       	rjmp	.-56     	; 0x3ce <simpleserial_put+0x22>
	}

	// Write trailing '\n'
	putch('\n');
 406:	8a e0       	ldi	r24, 0x0A	; 10
}
 408:	df 91       	pop	r29
 40a:	cf 91       	pop	r28
 40c:	1f 91       	pop	r17
 40e:	0f 91       	pop	r16
 410:	ff 90       	pop	r15
 412:	ef 90       	pop	r14
 414:	df 90       	pop	r13
 416:	cf 90       	pop	r12
		putch(hex_lookup[output[i] >> 4 ]);
		putch(hex_lookup[output[i] & 0xF]);
	}

	// Write trailing '\n'
	putch('\n');
 418:	0c 94 70 03 	jmp	0x6e0	; 0x6e0 <output_ch_0>
}
 41c:	df 91       	pop	r29
 41e:	cf 91       	pop	r28
 420:	1f 91       	pop	r17
 422:	0f 91       	pop	r16
 424:	ff 90       	pop	r15
 426:	ef 90       	pop	r14
 428:	df 90       	pop	r13
 42a:	cf 90       	pop	r12
 42c:	08 95       	ret

0000042e <ss_num_commands>:
{
	return SS_VER;
}

uint8_t ss_num_commands(uint8_t *x, uint8_t len)
{
 42e:	cf 93       	push	r28
 430:	df 93       	push	r29
 432:	1f 92       	push	r1
 434:	cd b7       	in	r28, 0x3d	; 61
 436:	de b7       	in	r29, 0x3e	; 62
    uint8_t ncmds = num_commands & 0xFF;
 438:	80 91 fc 22 	lds	r24, 0x22FC	; 0x8022fc <num_commands>
 43c:	89 83       	std	Y+1, r24	; 0x01
    simpleserial_put('r', 0x01, &ncmds);
 43e:	ae 01       	movw	r20, r28
 440:	4f 5f       	subi	r20, 0xFF	; 255
 442:	5f 4f       	sbci	r21, 0xFF	; 255
 444:	61 e0       	ldi	r22, 0x01	; 1
 446:	82 e7       	ldi	r24, 0x72	; 114
 448:	0e 94 d6 01 	call	0x3ac	; 0x3ac <simpleserial_put>
    return 0x00;
}
 44c:	80 e0       	ldi	r24, 0x00	; 0
 44e:	0f 90       	pop	r0
 450:	df 91       	pop	r29
 452:	cf 91       	pop	r28
 454:	08 95       	ret

00000456 <ss_get_commands>:
    uint8_t len;
    uint8_t flags;
} ss_cmd_repr;

uint8_t ss_get_commands(uint8_t *x, uint8_t len)
{
 456:	cf 93       	push	r28
 458:	df 93       	push	r29
 45a:	cd b7       	in	r28, 0x3d	; 61
 45c:	de b7       	in	r29, 0x3e	; 62
 45e:	c0 56       	subi	r28, 0x60	; 96
 460:	d1 09       	sbc	r29, r1
 462:	cd bf       	out	0x3d, r28	; 61
 464:	de bf       	out	0x3e, r29	; 62
    ss_cmd_repr repr_cmd_buf[MAX_SS_CMDS];
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 466:	60 91 fc 22 	lds	r22, 0x22FC	; 0x8022fc <num_commands>
 46a:	70 91 fd 22 	lds	r23, 0x22FD	; 0x8022fd <num_commands+0x1>
 46e:	ab 01       	movw	r20, r22
 470:	55 27       	eor	r21, r21
 472:	20 e0       	ldi	r18, 0x00	; 0
        repr_cmd_buf[i].c = commands[i].c;
 474:	36 e0       	ldi	r19, 0x06	; 6
} ss_cmd_repr;

uint8_t ss_get_commands(uint8_t *x, uint8_t len)
{
    ss_cmd_repr repr_cmd_buf[MAX_SS_CMDS];
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 476:	82 2f       	mov	r24, r18
 478:	90 e0       	ldi	r25, 0x00	; 0
 47a:	84 17       	cp	r24, r20
 47c:	95 07       	cpc	r25, r21
 47e:	ec f4       	brge	.+58     	; 0x4ba <ss_get_commands+0x64>
        repr_cmd_buf[i].c = commands[i].c;
 480:	fc 01       	movw	r30, r24
 482:	ee 0f       	add	r30, r30
 484:	ff 1f       	adc	r31, r31
 486:	e8 0f       	add	r30, r24
 488:	f9 1f       	adc	r31, r25
 48a:	a1 e0       	ldi	r26, 0x01	; 1
 48c:	b0 e0       	ldi	r27, 0x00	; 0
 48e:	ac 0f       	add	r26, r28
 490:	bd 1f       	adc	r27, r29
 492:	ea 0f       	add	r30, r26
 494:	fb 1f       	adc	r31, r27
 496:	38 9f       	mul	r19, r24
 498:	d0 01       	movw	r26, r0
 49a:	39 9f       	mul	r19, r25
 49c:	b0 0d       	add	r27, r0
 49e:	11 24       	eor	r1, r1
 4a0:	a4 5c       	subi	r26, 0xC4	; 196
 4a2:	bd 4d       	sbci	r27, 0xDD	; 221
 4a4:	8c 91       	ld	r24, X
 4a6:	80 83       	st	Z, r24
        repr_cmd_buf[i].len = commands[i].len;
 4a8:	11 96       	adiw	r26, 0x01	; 1
 4aa:	8c 91       	ld	r24, X
 4ac:	11 97       	sbiw	r26, 0x01	; 1
 4ae:	81 83       	std	Z+1, r24	; 0x01
        repr_cmd_buf[i].flags = commands[i].flags;
 4b0:	15 96       	adiw	r26, 0x05	; 5
 4b2:	8c 91       	ld	r24, X
 4b4:	82 83       	std	Z+2, r24	; 0x02
} ss_cmd_repr;

uint8_t ss_get_commands(uint8_t *x, uint8_t len)
{
    ss_cmd_repr repr_cmd_buf[MAX_SS_CMDS];
    for (uint8_t i = 0; i < (num_commands & 0xFF); i++) {
 4b6:	2f 5f       	subi	r18, 0xFF	; 255
 4b8:	de cf       	rjmp	.-68     	; 0x476 <ss_get_commands+0x20>
        repr_cmd_buf[i].c = commands[i].c;
        repr_cmd_buf[i].len = commands[i].len;
        repr_cmd_buf[i].flags = commands[i].flags;
    }

    simpleserial_put('r', num_commands * sizeof (ss_cmd_repr), (void *) repr_cmd_buf);
 4ba:	86 2f       	mov	r24, r22
 4bc:	88 0f       	add	r24, r24
 4be:	68 0f       	add	r22, r24
 4c0:	ae 01       	movw	r20, r28
 4c2:	4f 5f       	subi	r20, 0xFF	; 255
 4c4:	5f 4f       	sbci	r21, 0xFF	; 255
 4c6:	82 e7       	ldi	r24, 0x72	; 114
 4c8:	0e 94 d6 01 	call	0x3ac	; 0x3ac <simpleserial_put>
    return 0x00;
}
 4cc:	80 e0       	ldi	r24, 0x00	; 0
 4ce:	c0 5a       	subi	r28, 0xA0	; 160
 4d0:	df 4f       	sbci	r29, 0xFF	; 255
 4d2:	cd bf       	out	0x3d, r28	; 61
 4d4:	de bf       	out	0x3e, r29	; 62
 4d6:	df 91       	pop	r29
 4d8:	cf 91       	pop	r28
 4da:	08 95       	ret

000004dc <simpleserial_get>:

	return 0;
}

void simpleserial_get(void)
{
 4dc:	af 92       	push	r10
 4de:	bf 92       	push	r11
 4e0:	cf 92       	push	r12
 4e2:	df 92       	push	r13
 4e4:	ef 92       	push	r14
 4e6:	ff 92       	push	r15
 4e8:	0f 93       	push	r16
 4ea:	1f 93       	push	r17
 4ec:	cf 93       	push	r28
 4ee:	df 93       	push	r29
 4f0:	cd b7       	in	r28, 0x3d	; 61
 4f2:	de b7       	in	r29, 0x3e	; 62
 4f4:	c1 5c       	subi	r28, 0xC1	; 193
 4f6:	d1 09       	sbc	r29, r1
 4f8:	cd bf       	out	0x3d, r28	; 61
 4fa:	de bf       	out	0x3e, r29	; 62
	char ascii_buf[2*MAX_SS_LEN];
	uint8_t data_buf[MAX_SS_LEN];
	char c;

	// Find which command we're receiving
	c = getch();
 4fc:	0e 94 69 03 	call	0x6d2	; 0x6d2 <input_ch_0>

	int cmd;
	for(cmd = 0; cmd < num_commands; cmd++)
 500:	40 91 fc 22 	lds	r20, 0x22FC	; 0x8022fc <num_commands>
 504:	50 91 fd 22 	lds	r21, 0x22FD	; 0x8022fd <num_commands+0x1>
 508:	2c e3       	ldi	r18, 0x3C	; 60
 50a:	32 e2       	ldi	r19, 0x22	; 34
 50c:	00 e0       	ldi	r16, 0x00	; 0
 50e:	10 e0       	ldi	r17, 0x00	; 0
 510:	04 17       	cp	r16, r20
 512:	15 07       	cpc	r17, r21
 514:	ec f4       	brge	.+58     	; 0x550 <simpleserial_get+0x74>
 516:	2a 5f       	subi	r18, 0xFA	; 250
 518:	3f 4f       	sbci	r19, 0xFF	; 255
	{
		if(commands[cmd].c == c)
 51a:	f9 01       	movw	r30, r18
 51c:	36 97       	sbiw	r30, 0x06	; 6
 51e:	90 81       	ld	r25, Z
 520:	89 13       	cpse	r24, r25
 522:	13 c0       	rjmp	.+38     	; 0x54a <simpleserial_get+0x6e>
	// If we didn't find a match, give up right away
	if(cmd == num_commands)
		return;

	// If flag CMD_FLAG_LEN is set, the next byte indicates the sent length
	if ((commands[cmd].flags & CMD_FLAG_LEN) != 0)
 524:	26 e0       	ldi	r18, 0x06	; 6
 526:	20 9f       	mul	r18, r16
 528:	c0 01       	movw	r24, r0
 52a:	21 9f       	mul	r18, r17
 52c:	90 0d       	add	r25, r0
 52e:	11 24       	eor	r1, r1
 530:	9c 01       	movw	r18, r24
 532:	24 5c       	subi	r18, 0xC4	; 196
 534:	3d 4d       	sbci	r19, 0xDD	; 221
 536:	69 01       	movw	r12, r18
 538:	d9 01       	movw	r26, r18
 53a:	15 96       	adiw	r26, 0x05	; 5
 53c:	8c 91       	ld	r24, X
 53e:	fe 01       	movw	r30, r28
 540:	31 96       	adiw	r30, 0x01	; 1
 542:	7f 01       	movw	r14, r30
 544:	80 ff       	sbrs	r24, 0
 546:	2a c0       	rjmp	.+84     	; 0x59c <simpleserial_get+0xc0>
 548:	08 c0       	rjmp	.+16     	; 0x55a <simpleserial_get+0x7e>

	// Find which command we're receiving
	c = getch();

	int cmd;
	for(cmd = 0; cmd < num_commands; cmd++)
 54a:	0f 5f       	subi	r16, 0xFF	; 255
 54c:	1f 4f       	sbci	r17, 0xFF	; 255
 54e:	e0 cf       	rjmp	.-64     	; 0x510 <simpleserial_get+0x34>
		if(commands[cmd].c == c)
			break;
	}

	// If we didn't find a match, give up right away
	if(cmd == num_commands)
 550:	04 17       	cp	r16, r20
 552:	15 07       	cpc	r17, r21
 554:	09 f4       	brne	.+2      	; 0x558 <simpleserial_get+0x7c>
 556:	76 c0       	rjmp	.+236    	; 0x644 <simpleserial_get+0x168>
 558:	e5 cf       	rjmp	.-54     	; 0x524 <simpleserial_get+0x48>
		return;

	// If flag CMD_FLAG_LEN is set, the next byte indicates the sent length
	if ((commands[cmd].flags & CMD_FLAG_LEN) != 0)
	{
		uint8_t l = 0;
 55a:	cf 57       	subi	r28, 0x7F	; 127
 55c:	df 4f       	sbci	r29, 0xFF	; 255
 55e:	18 82       	st	Y, r1
 560:	c1 58       	subi	r28, 0x81	; 129
 562:	d0 40       	sbci	r29, 0x00	; 0
		char buff[2];
		buff[0] = getch();
 564:	0e 94 69 03 	call	0x6d2	; 0x6d2 <input_ch_0>
 568:	89 83       	std	Y+1, r24	; 0x01
		buff[1] = getch();
 56a:	0e 94 69 03 	call	0x6d2	; 0x6d2 <input_ch_0>
 56e:	8a 83       	std	Y+2, r24	; 0x02
		if (hex_decode(1, buff, &l))
 570:	ae 01       	movw	r20, r28
 572:	4f 57       	subi	r20, 0x7F	; 127
 574:	5f 4f       	sbci	r21, 0xFF	; 255
 576:	b7 01       	movw	r22, r14
 578:	81 e0       	ldi	r24, 0x01	; 1
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	0e 94 56 01 	call	0x2ac	; 0x2ac <hex_decode>
 580:	89 2b       	or	r24, r25
 582:	09 f0       	breq	.+2      	; 0x586 <simpleserial_get+0xaa>
 584:	5f c0       	rjmp	.+190    	; 0x644 <simpleserial_get+0x168>
			return;
		commands[cmd].len = l;
 586:	cf 57       	subi	r28, 0x7F	; 127
 588:	df 4f       	sbci	r29, 0xFF	; 255
 58a:	88 81       	ld	r24, Y
 58c:	c1 58       	subi	r28, 0x81	; 129
 58e:	d0 40       	sbci	r29, 0x00	; 0
 590:	90 e0       	ldi	r25, 0x00	; 0
 592:	d6 01       	movw	r26, r12
 594:	11 96       	adiw	r26, 0x01	; 1
 596:	8d 93       	st	X+, r24
 598:	9c 93       	st	X, r25
 59a:	12 97       	sbiw	r26, 0x02	; 2

	// Find which command we're receiving
	c = getch();

	int cmd;
	for(cmd = 0; cmd < num_commands; cmd++)
 59c:	67 01       	movw	r12, r14
			return;
		commands[cmd].len = l;
	}

	// Receive characters until we fill the ASCII buffer
	for(int i = 0; i < 2*commands[cmd].len; i++)
 59e:	26 e0       	ldi	r18, 0x06	; 6
 5a0:	20 9f       	mul	r18, r16
 5a2:	c0 01       	movw	r24, r0
 5a4:	21 9f       	mul	r18, r17
 5a6:	90 0d       	add	r25, r0
 5a8:	11 24       	eor	r1, r1
 5aa:	fc 01       	movw	r30, r24
 5ac:	e3 5c       	subi	r30, 0xC3	; 195
 5ae:	fd 4d       	sbci	r31, 0xDD	; 221
 5b0:	5f 01       	movw	r10, r30
 5b2:	f5 01       	movw	r30, r10
 5b4:	80 81       	ld	r24, Z
 5b6:	91 81       	ldd	r25, Z+1	; 0x01
 5b8:	88 0f       	add	r24, r24
 5ba:	99 1f       	adc	r25, r25
 5bc:	96 01       	movw	r18, r12
 5be:	2e 19       	sub	r18, r14
 5c0:	3f 09       	sbc	r19, r15
 5c2:	28 17       	cp	r18, r24
 5c4:	39 07       	cpc	r19, r25
 5c6:	50 f4       	brcc	.+20     	; 0x5dc <simpleserial_get+0x100>
	{
		c = getch();
 5c8:	0e 94 69 03 	call	0x6d2	; 0x6d2 <input_ch_0>

		// Check for early \n
		if(c == '\n' || c == '\r')
 5cc:	8a 30       	cpi	r24, 0x0A	; 10
 5ce:	d1 f1       	breq	.+116    	; 0x644 <simpleserial_get+0x168>
 5d0:	8d 30       	cpi	r24, 0x0D	; 13
 5d2:	c1 f1       	breq	.+112    	; 0x644 <simpleserial_get+0x168>
			return;

		ascii_buf[i] = c;
 5d4:	d6 01       	movw	r26, r12
 5d6:	8d 93       	st	X+, r24
 5d8:	6d 01       	movw	r12, r26
 5da:	eb cf       	rjmp	.-42     	; 0x5b2 <simpleserial_get+0xd6>
	}

	// Assert that last character is \n or \r
	c = getch();
 5dc:	0e 94 69 03 	call	0x6d2	; 0x6d2 <input_ch_0>
	if(c != '\n' && c != '\r')
 5e0:	8a 30       	cpi	r24, 0x0A	; 10
 5e2:	11 f0       	breq	.+4      	; 0x5e8 <simpleserial_get+0x10c>
 5e4:	8d 30       	cpi	r24, 0x0D	; 13
 5e6:	71 f5       	brne	.+92     	; 0x644 <simpleserial_get+0x168>
		return;

	// ASCII buffer is full: convert to bytes
	// Check for illegal characters here
	if(hex_decode(commands[cmd].len, ascii_buf, data_buf))
 5e8:	26 e0       	ldi	r18, 0x06	; 6
 5ea:	20 9f       	mul	r18, r16
 5ec:	c0 01       	movw	r24, r0
 5ee:	21 9f       	mul	r18, r17
 5f0:	90 0d       	add	r25, r0
 5f2:	11 24       	eor	r1, r1
 5f4:	8c 01       	movw	r16, r24
 5f6:	04 5c       	subi	r16, 0xC4	; 196
 5f8:	1d 4d       	sbci	r17, 0xDD	; 221
 5fa:	d8 01       	movw	r26, r16
 5fc:	11 96       	adiw	r26, 0x01	; 1
 5fe:	dc 90       	ld	r13, X
 600:	11 97       	sbiw	r26, 0x01	; 1
 602:	ae 01       	movw	r20, r28
 604:	4f 57       	subi	r20, 0x7F	; 127
 606:	5f 4f       	sbci	r21, 0xFF	; 255
 608:	b7 01       	movw	r22, r14
 60a:	8d 2d       	mov	r24, r13
 60c:	12 96       	adiw	r26, 0x02	; 2
 60e:	9c 91       	ld	r25, X
 610:	0e 94 56 01 	call	0x2ac	; 0x2ac <hex_decode>
 614:	89 2b       	or	r24, r25
 616:	b1 f4       	brne	.+44     	; 0x644 <simpleserial_get+0x168>
		return;

	// Callback
	uint8_t ret[1];
	ret[0] = commands[cmd].fp(data_buf, commands[cmd].len);
 618:	d8 01       	movw	r26, r16
 61a:	13 96       	adiw	r26, 0x03	; 3
 61c:	ed 91       	ld	r30, X+
 61e:	fc 91       	ld	r31, X
 620:	14 97       	sbiw	r26, 0x04	; 4
 622:	6d 2d       	mov	r22, r13
 624:	ce 01       	movw	r24, r28
 626:	8f 57       	subi	r24, 0x7F	; 127
 628:	9f 4f       	sbci	r25, 0xFF	; 255
 62a:	19 95       	eicall
 62c:	cf 53       	subi	r28, 0x3F	; 63
 62e:	df 4f       	sbci	r29, 0xFF	; 255
 630:	88 83       	st	Y, r24
 632:	c1 5c       	subi	r28, 0xC1	; 193
 634:	d0 40       	sbci	r29, 0x00	; 0

	// Acknowledge (if version is 1.1)
#if SS_VER == SS_VER_1_1
	simpleserial_put('z', 1, ret);
 636:	ae 01       	movw	r20, r28
 638:	4f 53       	subi	r20, 0x3F	; 63
 63a:	5f 4f       	sbci	r21, 0xFF	; 255
 63c:	61 e0       	ldi	r22, 0x01	; 1
 63e:	8a e7       	ldi	r24, 0x7A	; 122
 640:	0e 94 d6 01 	call	0x3ac	; 0x3ac <simpleserial_put>
#endif
}
 644:	cf 53       	subi	r28, 0x3F	; 63
 646:	df 4f       	sbci	r29, 0xFF	; 255
 648:	cd bf       	out	0x3d, r28	; 61
 64a:	de bf       	out	0x3e, r29	; 62
 64c:	df 91       	pop	r29
 64e:	cf 91       	pop	r28
 650:	1f 91       	pop	r17
 652:	0f 91       	pop	r16
 654:	ff 90       	pop	r15
 656:	ef 90       	pop	r14
 658:	df 90       	pop	r13
 65a:	cf 90       	pop	r12
 65c:	bf 90       	pop	r11
 65e:	af 90       	pop	r10
 660:	08 95       	ret

00000662 <led_ok>:
 662:	08 95       	ret

00000664 <led_error>:
__attribute__((weak)) void led_ok(unsigned int status)
{
}

__attribute__((weak)) void led_error(unsigned int status)
{
 664:	08 95       	ret

00000666 <init_uart0>:
   )
   {
/* This PORT setting is only valid to USARTC0 if other USARTs is used a
	 * different PORT and/or pins is used. */
	/* PIN3 (TXD0) as output. */
	PORTC.DIRSET = PIN3_bm;
 666:	e0 e4       	ldi	r30, 0x40	; 64
 668:	f6 e0       	ldi	r31, 0x06	; 6
 66a:	88 e0       	ldi	r24, 0x08	; 8
 66c:	81 83       	std	Z+1, r24	; 0x01

	/* PC2 (RXD0) as input. */
	PORTC.DIRCLR = PIN2_bm;
 66e:	84 e0       	ldi	r24, 0x04	; 4
 670:	82 83       	std	Z+2, r24	; 0x02

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(&USART, USART_CHSIZE_8BIT_gc, USART_PMODE_DISABLED_gc, false);
 672:	e0 ea       	ldi	r30, 0xA0	; 160
 674:	f8 e0       	ldi	r31, 0x08	; 8
 676:	83 e0       	ldi	r24, 0x03	; 3
 678:	85 83       	std	Z+5, r24	; 0x05

        /* Set Baudrate to 115200 bps @ 32 MHz:
         * Baudrate select = (F_CPU/(16*Baud)) - 1
         *                 = 17
         */
        USART_Baudrate_Set(&USART, 17, 0);
 67a:	81 e1       	ldi	r24, 0x11	; 17
 67c:	86 83       	std	Z+6, r24	; 0x06
 67e:	17 82       	std	Z+7, r1	; 0x07

	/* Enable both RX and TX. */
	USART_Rx_Enable(&USART);
 680:	84 81       	ldd	r24, Z+4	; 0x04
 682:	80 61       	ori	r24, 0x10	; 16
 684:	84 83       	std	Z+4, r24	; 0x04
	USART_Tx_Enable(&USART);
 686:	84 81       	ldd	r24, Z+4	; 0x04
 688:	88 60       	ori	r24, 0x08	; 8
 68a:	84 83       	std	Z+4, r24	; 0x04
 68c:	08 95       	ret

0000068e <input_ch_w_timeout_0>:
unsigned char									input_ch_w_timeout_0
	(
   char *					 	data,
   volatile unsigned int				timeout
   )
   {
 68e:	cf 93       	push	r28
 690:	df 93       	push	r29
 692:	1f 92       	push	r1
 694:	1f 92       	push	r1
 696:	cd b7       	in	r28, 0x3d	; 61
 698:	de b7       	in	r29, 0x3e	; 62
 69a:	69 83       	std	Y+1, r22	; 0x01
 69c:	7a 83       	std	Y+2, r23	; 0x02
   unsigned int				timeout_counter = 0;
 69e:	20 e0       	ldi	r18, 0x00	; 0
 6a0:	30 e0       	ldi	r19, 0x00	; 0

   
   //check if a byte has been received or if the timeout has been exceeded
   while (timeout_counter != timeout)
 6a2:	49 81       	ldd	r20, Y+1	; 0x01
 6a4:	5a 81       	ldd	r21, Y+2	; 0x02
 6a6:	24 17       	cp	r18, r20
 6a8:	35 07       	cpc	r19, r21
 6aa:	69 f0       	breq	.+26     	; 0x6c6 <input_ch_w_timeout_0+0x38>
		{	
		if (USART_IsRXComplete(&USART))
 6ac:	40 91 a1 08 	lds	r20, 0x08A1	; 0x8008a1 <__TEXT_REGION_LENGTH__+0x7de8a1>
 6b0:	47 ff       	sbrs	r20, 7
 6b2:	06 c0       	rjmp	.+12     	; 0x6c0 <input_ch_w_timeout_0+0x32>
			{
			*data = USART_GetChar(&USART);
 6b4:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7de8a0>
 6b8:	fc 01       	movw	r30, r24
 6ba:	20 83       	st	Z, r18
			return BYTE_REC;
 6bc:	81 e0       	ldi	r24, 0x01	; 1
 6be:	04 c0       	rjmp	.+8      	; 0x6c8 <input_ch_w_timeout_0+0x3a>
			}
		timeout_counter++;
 6c0:	2f 5f       	subi	r18, 0xFF	; 255
 6c2:	3f 4f       	sbci	r19, 0xFF	; 255
 6c4:	ee cf       	rjmp	.-36     	; 0x6a2 <input_ch_w_timeout_0+0x14>
		}
		
	return TIMEOUT;
 6c6:	80 e0       	ldi	r24, 0x00	; 0
	}
 6c8:	0f 90       	pop	r0
 6ca:	0f 90       	pop	r0
 6cc:	df 91       	pop	r29
 6ce:	cf 91       	pop	r28
 6d0:	08 95       	ret

000006d2 <input_ch_0>:
	(
   void
   )
   {
   //check if a byte has been received or if the timeout has been exceeded
   while (!USART_IsRXComplete(&USART))
 6d2:	80 91 a1 08 	lds	r24, 0x08A1	; 0x8008a1 <__TEXT_REGION_LENGTH__+0x7de8a1>
 6d6:	87 ff       	sbrs	r24, 7
 6d8:	fc cf       	rjmp	.-8      	; 0x6d2 <input_ch_0>
		{
		continue;		
		}		
        return USART_GetChar(&USART);
 6da:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7de8a0>
	}
 6de:	08 95       	ret

000006e0 <output_ch_0>:
void												output_ch_0
	(
	char							data
	)
	{
        while(!USART_IsTXDataRegisterEmpty(&USART)) {
 6e0:	90 91 a1 08 	lds	r25, 0x08A1	; 0x8008a1 <__TEXT_REGION_LENGTH__+0x7de8a1>
 6e4:	95 ff       	sbrs	r25, 5
 6e6:	fc cf       	rjmp	.-8      	; 0x6e0 <output_ch_0>
                ;
        }
        USART_PutChar(&USART, data);
 6e8:	80 93 a0 08 	sts	0x08A0, r24	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7de8a0>
 6ec:	08 95       	ret

000006ee <USART_InterruptDriver_Initialize>:
 *  \param dreIntLevel          Data register empty interrupt level.
 */
void USART_InterruptDriver_Initialize(USART_data_t * usart_data,
                                      USART_t * usart,
                                      USART_DREINTLVL_t dreIntLevel)
{
 6ee:	fc 01       	movw	r30, r24
	usart_data->usart = usart;
 6f0:	60 83       	st	Z, r22
 6f2:	71 83       	std	Z+1, r23	; 0x01
	usart_data->dreIntLevel = dreIntLevel;
 6f4:	42 83       	std	Z+2, r20	; 0x02

	usart_data->buffer.RX_Tail = 0;
 6f6:	14 86       	std	Z+12, r1	; 0x0c
	usart_data->buffer.RX_Head = 0;
 6f8:	13 86       	std	Z+11, r1	; 0x0b
	usart_data->buffer.TX_Tail = 0;
 6fa:	16 86       	std	Z+14, r1	; 0x0e
	usart_data->buffer.TX_Head = 0;
 6fc:	15 86       	std	Z+13, r1	; 0x0d
 6fe:	08 95       	ret

00000700 <USART_InterruptDriver_DreInterruptLevel_Set>:
 *  \param dreIntLevel        Interrupt level of the DRE interrupt.
 */
void USART_InterruptDriver_DreInterruptLevel_Set(USART_data_t * usart_data,
                                                 USART_DREINTLVL_t dreIntLevel)
{
	usart_data->dreIntLevel = dreIntLevel;
 700:	fc 01       	movw	r30, r24
 702:	62 83       	std	Z+2, r22	; 0x02
 704:	08 95       	ret

00000706 <USART_TXBuffer_FreeSpace>:
 *
 *  \retval true      There is data in the receive buffer.
 *  \retval false     The receive buffer is empty.
 */
bool USART_TXBuffer_FreeSpace(USART_data_t * usart_data)
{
 706:	fc 01       	movw	r30, r24
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = (usart_data->buffer.TX_Head + 1) & USART_TX_BUFFER_MASK;
 708:	95 85       	ldd	r25, Z+13	; 0x0d
	uint8_t tempTail = usart_data->buffer.TX_Tail;
 70a:	26 85       	ldd	r18, Z+14	; 0x0e

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 70c:	9f 5f       	subi	r25, 0xFF	; 255
 70e:	93 70       	andi	r25, 0x03	; 3
 710:	81 e0       	ldi	r24, 0x01	; 1
 712:	92 13       	cpse	r25, r18
 714:	01 c0       	rjmp	.+2      	; 0x718 <USART_TXBuffer_FreeSpace+0x12>
 716:	80 e0       	ldi	r24, 0x00	; 0
}
 718:	08 95       	ret

0000071a <USART_TXBuffer_PutByte>:
 *
 *  \param usart_data The USART_data_t struct instance.
 *  \param data       The data to send.
 */
bool USART_TXBuffer_PutByte(USART_data_t * usart_data, uint8_t data)
{
 71a:	1f 93       	push	r17
 71c:	cf 93       	push	r28
 71e:	df 93       	push	r29
 720:	ec 01       	movw	r28, r24
 722:	16 2f       	mov	r17, r22
	uint8_t tempTX_Head;
	bool TXBuffer_FreeSpace;
	USART_Buffer_t * TXbufPtr;

	TXbufPtr = &usart_data->buffer;
	TXBuffer_FreeSpace = USART_TXBuffer_FreeSpace(usart_data);
 724:	0e 94 83 03 	call	0x706	; 0x706 <USART_TXBuffer_FreeSpace>


	if(TXBuffer_FreeSpace)
 728:	88 23       	and	r24, r24
 72a:	79 f0       	breq	.+30     	; 0x74a <USART_TXBuffer_PutByte+0x30>
	{
	  	tempTX_Head = TXbufPtr->TX_Head;
 72c:	9d 85       	ldd	r25, Y+13	; 0x0d
	  	TXbufPtr->TX[tempTX_Head]= data;
 72e:	fe 01       	movw	r30, r28
 730:	e9 0f       	add	r30, r25
 732:	f1 1d       	adc	r31, r1
 734:	17 83       	std	Z+7, r17	; 0x07
		/* Advance buffer head. */
		TXbufPtr->TX_Head = (tempTX_Head + 1) & USART_TX_BUFFER_MASK;
 736:	9f 5f       	subi	r25, 0xFF	; 255
 738:	93 70       	andi	r25, 0x03	; 3
 73a:	9d 87       	std	Y+13, r25	; 0x0d

		/* Enable DRE interrupt. */
		tempCTRLA = usart_data->usart->CTRLA;
 73c:	e8 81       	ld	r30, Y
 73e:	f9 81       	ldd	r31, Y+1	; 0x01
 740:	93 81       	ldd	r25, Z+3	; 0x03
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | usart_data->dreIntLevel;
 742:	9c 7f       	andi	r25, 0xFC	; 252
 744:	2a 81       	ldd	r18, Y+2	; 0x02
 746:	92 2b       	or	r25, r18
		usart_data->usart->CTRLA = tempCTRLA;
 748:	93 83       	std	Z+3, r25	; 0x03
	}
	return TXBuffer_FreeSpace;
}
 74a:	df 91       	pop	r29
 74c:	cf 91       	pop	r28
 74e:	1f 91       	pop	r17
 750:	08 95       	ret

00000752 <USART_RXBufferData_Available>:
 *  \retval false     The receive buffer is empty.
 */
bool USART_RXBufferData_Available(USART_data_t * usart_data)
{
	/* Make copies to make sure that volatile access is specified. */
	uint8_t tempHead = usart_data->buffer.RX_Head;
 752:	fc 01       	movw	r30, r24
 754:	23 85       	ldd	r18, Z+11	; 0x0b
	uint8_t tempTail = usart_data->buffer.RX_Tail;
 756:	94 85       	ldd	r25, Z+12	; 0x0c

	/* There are data left in the buffer unless Head and Tail are equal. */
	return (tempHead != tempTail);
 758:	81 e0       	ldi	r24, 0x01	; 1
 75a:	29 13       	cpse	r18, r25
 75c:	01 c0       	rjmp	.+2      	; 0x760 <USART_RXBufferData_Available+0xe>
 75e:	80 e0       	ldi	r24, 0x00	; 0
}
 760:	08 95       	ret

00000762 <USART_RXBuffer_GetByte>:
 *  \param usart_data       The USART_data_t struct instance.
 *
 *  \return         Received data.
 */
uint8_t USART_RXBuffer_GetByte(USART_data_t * usart_data)
{
 762:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	uint8_t ans;

	bufPtr = &usart_data->buffer;
	ans = (bufPtr->RX[bufPtr->RX_Tail]);
 764:	84 85       	ldd	r24, Z+12	; 0x0c
 766:	df 01       	movw	r26, r30
 768:	a8 0f       	add	r26, r24
 76a:	b1 1d       	adc	r27, r1
 76c:	13 96       	adiw	r26, 0x03	; 3
 76e:	8c 91       	ld	r24, X

	/* Advance buffer tail. */
	bufPtr->RX_Tail = (bufPtr->RX_Tail + 1) & USART_RX_BUFFER_MASK;
 770:	94 85       	ldd	r25, Z+12	; 0x0c
 772:	9f 5f       	subi	r25, 0xFF	; 255
 774:	93 70       	andi	r25, 0x03	; 3
 776:	94 87       	std	Z+12, r25	; 0x0c

	return ans;
}
 778:	08 95       	ret

0000077a <USART_RXComplete>:
 *  Stores received data in RX software buffer.
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
bool USART_RXComplete(USART_data_t * usart_data)
{
 77a:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	bool ans;

	bufPtr = &usart_data->buffer;
	/* Advance buffer head. */
	uint8_t tempRX_Head = (bufPtr->RX_Head + 1) & USART_RX_BUFFER_MASK;
 77c:	83 85       	ldd	r24, Z+11	; 0x0b
 77e:	8f 5f       	subi	r24, 0xFF	; 255
 780:	83 70       	andi	r24, 0x03	; 3

	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
 782:	24 85       	ldd	r18, Z+12	; 0x0c
	uint8_t data = usart_data->usart->DATA;
 784:	a0 81       	ld	r26, Z
 786:	b1 81       	ldd	r27, Z+1	; 0x01
 788:	9c 91       	ld	r25, X

	if (tempRX_Head == tempRX_Tail) {
 78a:	82 17       	cp	r24, r18
 78c:	49 f0       	breq	.+18     	; 0x7a0 <USART_RXComplete+0x26>
	  	ans = false;
	}else{
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
 78e:	23 85       	ldd	r18, Z+11	; 0x0b
 790:	df 01       	movw	r26, r30
 792:	a2 0f       	add	r26, r18
 794:	b1 1d       	adc	r27, r1
 796:	13 96       	adiw	r26, 0x03	; 3
 798:	9c 93       	st	X, r25
		usart_data->buffer.RX_Head = tempRX_Head;
 79a:	83 87       	std	Z+11, r24	; 0x0b
	uint8_t data = usart_data->usart->DATA;

	if (tempRX_Head == tempRX_Tail) {
	  	ans = false;
	}else{
		ans = true;
 79c:	81 e0       	ldi	r24, 0x01	; 1
 79e:	08 95       	ret
	/* Check for overflow. */
	uint8_t tempRX_Tail = bufPtr->RX_Tail;
	uint8_t data = usart_data->usart->DATA;

	if (tempRX_Head == tempRX_Tail) {
	  	ans = false;
 7a0:	80 e0       	ldi	r24, 0x00	; 0
		ans = true;
		usart_data->buffer.RX[usart_data->buffer.RX_Head] = data;
		usart_data->buffer.RX_Head = tempRX_Head;
	}
	return ans;
}
 7a2:	08 95       	ret

000007a4 <USART_DataRegEmpty>:
 *  is empty. Argument is pointer to USART (USART_data_t).
 *
 *  \param usart_data      The USART_data_t struct instance.
 */
void USART_DataRegEmpty(USART_data_t * usart_data)
{
 7a4:	cf 93       	push	r28
 7a6:	df 93       	push	r29
 7a8:	fc 01       	movw	r30, r24
	USART_Buffer_t * bufPtr;
	bufPtr = &usart_data->buffer;

	/* Check if all data is transmitted. */
	uint8_t tempTX_Tail = usart_data->buffer.TX_Tail;
 7aa:	96 85       	ldd	r25, Z+14	; 0x0e
	if (bufPtr->TX_Head == tempTX_Tail){
 7ac:	85 85       	ldd	r24, Z+13	; 0x0d
 7ae:	a0 81       	ld	r26, Z
 7b0:	b1 81       	ldd	r27, Z+1	; 0x01
 7b2:	98 13       	cpse	r25, r24
 7b4:	07 c0       	rjmp	.+14     	; 0x7c4 <USART_DataRegEmpty+0x20>
	    /* Disable DRE interrupts. */
		uint8_t tempCTRLA = usart_data->usart->CTRLA;
 7b6:	13 96       	adiw	r26, 0x03	; 3
 7b8:	8c 91       	ld	r24, X
 7ba:	13 97       	sbiw	r26, 0x03	; 3
		tempCTRLA = (tempCTRLA & ~USART_DREINTLVL_gm) | USART_DREINTLVL_OFF_gc;
 7bc:	8c 7f       	andi	r24, 0xFC	; 252
		usart_data->usart->CTRLA = tempCTRLA;
 7be:	13 96       	adiw	r26, 0x03	; 3
 7c0:	8c 93       	st	X, r24
 7c2:	0a c0       	rjmp	.+20     	; 0x7d8 <USART_DataRegEmpty+0x34>

	}else{
		/* Start transmitting. */
		uint8_t data = bufPtr->TX[usart_data->buffer.TX_Tail];
 7c4:	86 85       	ldd	r24, Z+14	; 0x0e
 7c6:	ef 01       	movw	r28, r30
 7c8:	c8 0f       	add	r28, r24
 7ca:	d1 1d       	adc	r29, r1
 7cc:	8f 81       	ldd	r24, Y+7	; 0x07
		usart_data->usart->DATA = data;
 7ce:	8c 93       	st	X, r24

		/* Advance buffer tail. */
		bufPtr->TX_Tail = (bufPtr->TX_Tail + 1) & USART_TX_BUFFER_MASK;
 7d0:	86 85       	ldd	r24, Z+14	; 0x0e
 7d2:	8f 5f       	subi	r24, 0xFF	; 255
 7d4:	83 70       	andi	r24, 0x03	; 3
 7d6:	86 87       	std	Z+14, r24	; 0x0e
	}
}
 7d8:	df 91       	pop	r29
 7da:	cf 91       	pop	r28
 7dc:	08 95       	ret

000007de <USART_NineBits_PutChar>:
 *
 *  \param usart      The USART module.
 *  \param data       The data to send.
 */
void USART_NineBits_PutChar(USART_t * usart, uint16_t data)
{
 7de:	fc 01       	movw	r30, r24
	if(data & 0x0100) {
		usart->CTRLB |= USART_TXB8_bm;
 7e0:	84 81       	ldd	r24, Z+4	; 0x04
 *  \param usart      The USART module.
 *  \param data       The data to send.
 */
void USART_NineBits_PutChar(USART_t * usart, uint16_t data)
{
	if(data & 0x0100) {
 7e2:	70 ff       	sbrs	r23, 0
 7e4:	02 c0       	rjmp	.+4      	; 0x7ea <USART_NineBits_PutChar+0xc>
		usart->CTRLB |= USART_TXB8_bm;
 7e6:	81 60       	ori	r24, 0x01	; 1
 7e8:	01 c0       	rjmp	.+2      	; 0x7ec <USART_NineBits_PutChar+0xe>
	}else {
		usart->CTRLB &= ~USART_TXB8_bm;
 7ea:	8e 7f       	andi	r24, 0xFE	; 254
 7ec:	84 83       	std	Z+4, r24	; 0x04
	}

	usart->DATA = (data & 0x00FF);
 7ee:	60 83       	st	Z, r22
 7f0:	08 95       	ret

000007f2 <USART_NineBits_GetChar>:
 *  \param usart      The USART module.
 *
 *  \retval           Received data.
 */
uint16_t USART_NineBits_GetChar(USART_t * usart)
{
 7f2:	fc 01       	movw	r30, r24
	if(usart->CTRLB & USART_RXB8_bm) {
 7f4:	84 81       	ldd	r24, Z+4	; 0x04
 7f6:	80 ff       	sbrs	r24, 0
 7f8:	04 c0       	rjmp	.+8      	; 0x802 <__EEPROM_REGION_LENGTH__+0x2>
		return(0x0100 | usart->DATA);
 7fa:	80 81       	ld	r24, Z
 7fc:	90 e0       	ldi	r25, 0x00	; 0
 7fe:	91 60       	ori	r25, 0x01	; 1
 800:	08 95       	ret
	}else {
		return(usart->DATA);
 802:	80 81       	ld	r24, Z
 804:	90 e0       	ldi	r25, 0x00	; 0
	}
}
 806:	08 95       	ret

00000808 <platform_init>:
#include "hal.h"
#include "xmega_hal.h"

void platform_init(void)
{  
    OSC.XOSCCTRL = 0x00;
 808:	10 92 52 00 	sts	0x0052, r1	; 0x800052 <__TEXT_REGION_LENGTH__+0x7de052>
    OSC.PLLCTRL = 0x00;
 80c:	10 92 55 00 	sts	0x0055, r1	; 0x800055 <__TEXT_REGION_LENGTH__+0x7de055>
    OSC.CTRL |= OSC_XOSCEN_bm;
 810:	80 91 50 00 	lds	r24, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
 814:	88 60       	ori	r24, 0x08	; 8
 816:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
    
    //wait for clock
    while((OSC.STATUS & OSC_XOSCRDY_bm) == 0);
 81a:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7de051>
 81e:	83 ff       	sbrs	r24, 3
 820:	fc cf       	rjmp	.-8      	; 0x81a <platform_init+0x12>
    
    //Switch clock source
    CCP = CCP_IOREG_gc;
 822:	88 ed       	ldi	r24, 0xD8	; 216
 824:	84 bf       	out	0x34, r24	; 52
    CLK.CTRL = CLK_SCLKSEL_XOSC_gc;    
 826:	83 e0       	ldi	r24, 0x03	; 3
 828:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7de040>
    
    //Turn off other sources besides external    
    OSC.CTRL = OSC_XOSCEN_bm;
 82c:	88 e0       	ldi	r24, 0x08	; 8
 82e:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7de050>
 832:	08 95       	ret

00000834 <KeyExpansion>:
  return rsbox[num];
}

// This function produces Nb(Nr+1) round keys. The round keys are used in each round to decrypt the states. 
static void KeyExpansion(void)
{
 834:	8f 92       	push	r8
 836:	9f 92       	push	r9
 838:	af 92       	push	r10
 83a:	bf 92       	push	r11
 83c:	ff 92       	push	r15
 83e:	0f 93       	push	r16
 840:	1f 93       	push	r17
 842:	cf 93       	push	r28
 844:	df 93       	push	r29
 846:	00 d0       	rcall	.+0      	; 0x848 <KeyExpansion+0x14>
 848:	1f 92       	push	r1
 84a:	cd b7       	in	r28, 0x3d	; 61
 84c:	de b7       	in	r29, 0x3e	; 62
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for(i = 0; i < Nk; ++i)
  {
    RoundKey[(i * 4) + 0] = Key[(i * 4) + 0];
 84e:	60 91 fe 22 	lds	r22, 0x22FE	; 0x8022fe <Key>
 852:	70 91 ff 22 	lds	r23, 0x22FF	; 0x8022ff <Key+0x1>
 856:	e0 e1       	ldi	r30, 0x10	; 16
 858:	f3 e2       	ldi	r31, 0x23	; 35
 85a:	9b 01       	movw	r18, r22
 85c:	20 5f       	subi	r18, 0xF0	; 240
 85e:	3f 4f       	sbci	r19, 0xFF	; 255
 860:	cf 01       	movw	r24, r30
 862:	db 01       	movw	r26, r22
 864:	4c 91       	ld	r20, X
 866:	dc 01       	movw	r26, r24
 868:	4c 93       	st	X, r20
    RoundKey[(i * 4) + 1] = Key[(i * 4) + 1];
 86a:	db 01       	movw	r26, r22
 86c:	11 96       	adiw	r26, 0x01	; 1
 86e:	4c 91       	ld	r20, X
 870:	dc 01       	movw	r26, r24
 872:	11 96       	adiw	r26, 0x01	; 1
 874:	4c 93       	st	X, r20
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
 876:	db 01       	movw	r26, r22
 878:	12 96       	adiw	r26, 0x02	; 2
 87a:	4c 91       	ld	r20, X
 87c:	dc 01       	movw	r26, r24
 87e:	12 96       	adiw	r26, 0x02	; 2
 880:	4c 93       	st	X, r20
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
 882:	db 01       	movw	r26, r22
 884:	13 96       	adiw	r26, 0x03	; 3
 886:	4c 91       	ld	r20, X
 888:	dc 01       	movw	r26, r24
 88a:	13 96       	adiw	r26, 0x03	; 3
 88c:	4c 93       	st	X, r20
 88e:	6c 5f       	subi	r22, 0xFC	; 252
 890:	7f 4f       	sbci	r23, 0xFF	; 255
 892:	04 96       	adiw	r24, 0x04	; 4
{
  uint32_t i, j, k;
  uint8_t tempa[4]; // Used for the column/row operations
  
  // The first round key is the key itself.
  for(i = 0; i < Nk; ++i)
 894:	62 17       	cp	r22, r18
 896:	73 07       	cpc	r23, r19
 898:	21 f7       	brne	.-56     	; 0x862 <KeyExpansion+0x2e>
 89a:	94 e0       	ldi	r25, 0x04	; 4
 89c:	89 2e       	mov	r8, r25
 89e:	91 2c       	mov	r9, r1
 8a0:	a1 2c       	mov	r10, r1
 8a2:	b1 2c       	mov	r11, r1
 8a4:	be 01       	movw	r22, r28
 8a6:	6b 5f       	subi	r22, 0xFB	; 251
 8a8:	7f 4f       	sbci	r23, 0xFF	; 255
 8aa:	af 01       	movw	r20, r30
 8ac:	44 5f       	subi	r20, 0xF4	; 244
 8ae:	5f 4f       	sbci	r21, 0xFF	; 255
 8b0:	9e 01       	movw	r18, r28
 8b2:	2f 5f       	subi	r18, 0xFF	; 255
 8b4:	3f 4f       	sbci	r19, 0xFF	; 255
  // All other round keys are found from the previous round keys.
  for(; (i < (Nb * (Nr + 1))); ++i)
  {
    for(j = 0; j < 4; ++j)
    {
      tempa[j]=RoundKey[(i-1) * 4 + j];
 8b6:	da 01       	movw	r26, r20
 8b8:	1d 91       	ld	r17, X+
 8ba:	ad 01       	movw	r20, r26
 8bc:	d9 01       	movw	r26, r18
 8be:	1d 93       	st	X+, r17
 8c0:	9d 01       	movw	r18, r26
  }

  // All other round keys are found from the previous round keys.
  for(; (i < (Nb * (Nr + 1))); ++i)
  {
    for(j = 0; j < 4; ++j)
 8c2:	6a 17       	cp	r22, r26
 8c4:	7b 07       	cpc	r23, r27
 8c6:	b9 f7       	brne	.-18     	; 0x8b6 <KeyExpansion+0x82>
    {
      tempa[j]=RoundKey[(i-1) * 4 + j];
    }
    if (i % Nk == 0)
 8c8:	95 01       	movw	r18, r10
 8ca:	84 01       	movw	r16, r8
 8cc:	03 70       	andi	r16, 0x03	; 3
 8ce:	11 27       	eor	r17, r17
 8d0:	22 27       	eor	r18, r18
 8d2:	33 27       	eor	r19, r19
 8d4:	01 2b       	or	r16, r17
 8d6:	02 2b       	or	r16, r18
 8d8:	03 2b       	or	r16, r19
 8da:	51 f5       	brne	.+84     	; 0x930 <KeyExpansion+0xfc>
      // This function rotates the 4 bytes in a word to the left once.
      // [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

      // Function RotWord()
      {
        k = tempa[0];
 8dc:	29 81       	ldd	r18, Y+1	; 0x01
        tempa[0] = tempa[1];
        tempa[1] = tempa[2];
        tempa[2] = tempa[3];
 8de:	4c 81       	ldd	r20, Y+4	; 0x04
/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
 8e0:	0a 81       	ldd	r16, Y+2	; 0x02
 8e2:	10 e0       	ldi	r17, 0x00	; 0
 8e4:	05 5f       	subi	r16, 0xF5	; 245
 8e6:	1e 4d       	sbci	r17, 0xDE	; 222
 8e8:	d8 01       	movw	r26, r16
 8ea:	fc 90       	ld	r15, X
 8ec:	0b 81       	ldd	r16, Y+3	; 0x03
 8ee:	10 e0       	ldi	r17, 0x00	; 0
 8f0:	05 5f       	subi	r16, 0xF5	; 245
 8f2:	1e 4d       	sbci	r17, 0xDE	; 222
      // applies the S-box to each of the four bytes to produce an output word.

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
 8f4:	d8 01       	movw	r26, r16
 8f6:	3c 91       	ld	r19, X
 8f8:	3a 83       	std	Y+2, r19	; 0x02
/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
 8fa:	50 e0       	ldi	r21, 0x00	; 0
 8fc:	45 5f       	subi	r20, 0xF5	; 245
 8fe:	5e 4d       	sbci	r21, 0xDE	; 222

      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
 900:	da 01       	movw	r26, r20
 902:	3c 91       	ld	r19, X
 904:	3b 83       	std	Y+3, r19	; 0x03
/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
 906:	30 e0       	ldi	r19, 0x00	; 0
 908:	25 5f       	subi	r18, 0xF5	; 245
 90a:	3e 4d       	sbci	r19, 0xDE	; 222
      // Function Subword()
      {
        tempa[0] = getSBoxValue(tempa[0]);
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
 90c:	d9 01       	movw	r26, r18
 90e:	2c 91       	ld	r18, X
 910:	2c 83       	std	Y+4, r18	; 0x04
      }

      tempa[0] =  tempa[0] ^ Rcon[i/Nk];
 912:	95 01       	movw	r18, r10
 914:	84 01       	movw	r16, r8
 916:	82 e0       	ldi	r24, 0x02	; 2
 918:	36 95       	lsr	r19
 91a:	27 95       	ror	r18
 91c:	17 95       	ror	r17
 91e:	07 95       	ror	r16
 920:	8a 95       	dec	r24
 922:	d1 f7       	brne	.-12     	; 0x918 <KeyExpansion+0xe4>
 924:	00 50       	subi	r16, 0x00	; 0
 926:	10 4e       	sbci	r17, 0xE0	; 224
 928:	d8 01       	movw	r26, r16
 92a:	2c 91       	ld	r18, X
 92c:	2f 25       	eor	r18, r15
 92e:	29 83       	std	Y+1, r18	; 0x01
        tempa[1] = getSBoxValue(tempa[1]);
        tempa[2] = getSBoxValue(tempa[2]);
        tempa[3] = getSBoxValue(tempa[3]);
      }
    }
    RoundKey[i * 4 + 0] = RoundKey[(i - Nk) * 4 + 0] ^ tempa[0];
 930:	30 81       	ld	r19, Z
 932:	29 81       	ldd	r18, Y+1	; 0x01
 934:	23 27       	eor	r18, r19
 936:	20 8b       	std	Z+16, r18	; 0x10
    RoundKey[i * 4 + 1] = RoundKey[(i - Nk) * 4 + 1] ^ tempa[1];
 938:	31 81       	ldd	r19, Z+1	; 0x01
 93a:	2a 81       	ldd	r18, Y+2	; 0x02
 93c:	23 27       	eor	r18, r19
 93e:	21 8b       	std	Z+17, r18	; 0x11
    RoundKey[i * 4 + 2] = RoundKey[(i - Nk) * 4 + 2] ^ tempa[2];
 940:	32 81       	ldd	r19, Z+2	; 0x02
 942:	2b 81       	ldd	r18, Y+3	; 0x03
 944:	23 27       	eor	r18, r19
 946:	22 8b       	std	Z+18, r18	; 0x12
    RoundKey[i * 4 + 3] = RoundKey[(i - Nk) * 4 + 3] ^ tempa[3];
 948:	33 81       	ldd	r19, Z+3	; 0x03
 94a:	2c 81       	ldd	r18, Y+4	; 0x04
 94c:	23 27       	eor	r18, r19
 94e:	23 8b       	std	Z+19, r18	; 0x13
    RoundKey[(i * 4) + 2] = Key[(i * 4) + 2];
    RoundKey[(i * 4) + 3] = Key[(i * 4) + 3];
  }

  // All other round keys are found from the previous round keys.
  for(; (i < (Nb * (Nr + 1))); ++i)
 950:	bf ef       	ldi	r27, 0xFF	; 255
 952:	8b 1a       	sub	r8, r27
 954:	9b 0a       	sbc	r9, r27
 956:	ab 0a       	sbc	r10, r27
 958:	bb 0a       	sbc	r11, r27
 95a:	34 96       	adiw	r30, 0x04	; 4
 95c:	8c e2       	ldi	r24, 0x2C	; 44
 95e:	88 16       	cp	r8, r24
 960:	91 04       	cpc	r9, r1
 962:	a1 04       	cpc	r10, r1
 964:	b1 04       	cpc	r11, r1
 966:	09 f0       	breq	.+2      	; 0x96a <KeyExpansion+0x136>
 968:	a0 cf       	rjmp	.-192    	; 0x8aa <KeyExpansion+0x76>
    RoundKey[i * 4 + 0] = RoundKey[(i - Nk) * 4 + 0] ^ tempa[0];
    RoundKey[i * 4 + 1] = RoundKey[(i - Nk) * 4 + 1] ^ tempa[1];
    RoundKey[i * 4 + 2] = RoundKey[(i - Nk) * 4 + 2] ^ tempa[2];
    RoundKey[i * 4 + 3] = RoundKey[(i - Nk) * 4 + 3] ^ tempa[3];
  }
}
 96a:	24 96       	adiw	r28, 0x04	; 4
 96c:	cd bf       	out	0x3d, r28	; 61
 96e:	de bf       	out	0x3e, r29	; 62
 970:	df 91       	pop	r29
 972:	cf 91       	pop	r28
 974:	1f 91       	pop	r17
 976:	0f 91       	pop	r16
 978:	ff 90       	pop	r15
 97a:	bf 90       	pop	r11
 97c:	af 90       	pop	r10
 97e:	9f 90       	pop	r9
 980:	8f 90       	pop	r8
 982:	08 95       	ret

00000984 <AddRoundKey>:

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round)
{
 984:	cf 93       	push	r28
 986:	df 93       	push	r29
  uint8_t i,j;
  for(i=0;i<4;++i)
  {
    for(j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[round * Nb * 4 + i * Nb + j];
 988:	60 91 c0 23 	lds	r22, 0x23C0	; 0x8023c0 <state>
 98c:	70 91 c1 23 	lds	r23, 0x23C1	; 0x8023c1 <state+0x1>
 990:	90 e1       	ldi	r25, 0x10	; 16
 992:	89 9f       	mul	r24, r25
 994:	e0 01       	movw	r28, r0
 996:	11 24       	eor	r1, r1
 998:	20 e0       	ldi	r18, 0x00	; 0
 99a:	30 e0       	ldi	r19, 0x00	; 0
 99c:	f9 01       	movw	r30, r18
 99e:	ec 0f       	add	r30, r28
 9a0:	fd 1f       	adc	r31, r29
 9a2:	e0 5f       	subi	r30, 0xF0	; 240
 9a4:	fc 4d       	sbci	r31, 0xDC	; 220
 9a6:	db 01       	movw	r26, r22
 9a8:	a2 0f       	add	r26, r18
 9aa:	b3 1f       	adc	r27, r19
}

// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round)
{
 9ac:	90 e0       	ldi	r25, 0x00	; 0
  uint8_t i,j;
  for(i=0;i<4;++i)
  {
    for(j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[round * Nb * 4 + i * Nb + j];
 9ae:	41 91       	ld	r20, Z+
 9b0:	8c 91       	ld	r24, X
 9b2:	48 27       	eor	r20, r24
 9b4:	4d 93       	st	X+, r20
static void AddRoundKey(uint8_t round)
{
  uint8_t i,j;
  for(i=0;i<4;++i)
  {
    for(j = 0; j < 4; ++j)
 9b6:	9f 5f       	subi	r25, 0xFF	; 255
 9b8:	94 30       	cpi	r25, 0x04	; 4
 9ba:	c9 f7       	brne	.-14     	; 0x9ae <AddRoundKey+0x2a>
 9bc:	2c 5f       	subi	r18, 0xFC	; 252
 9be:	3f 4f       	sbci	r19, 0xFF	; 255
// This function adds the round key to state.
// The round key is added to the state by an XOR function.
static void AddRoundKey(uint8_t round)
{
  uint8_t i,j;
  for(i=0;i<4;++i)
 9c0:	20 31       	cpi	r18, 0x10	; 16
 9c2:	31 05       	cpc	r19, r1
 9c4:	59 f7       	brne	.-42     	; 0x99c <AddRoundKey+0x18>
    for(j = 0; j < 4; ++j)
    {
      (*state)[i][j] ^= RoundKey[round * Nb * 4 + i * Nb + j];
    }
  }
}
 9c6:	df 91       	pop	r29
 9c8:	cf 91       	pop	r28
 9ca:	08 95       	ret

000009cc <SubBytes>:

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(void)
{
 9cc:	20 91 c0 23 	lds	r18, 0x23C0	; 0x8023c0 <state>
 9d0:	30 91 c1 23 	lds	r19, 0x23C1	; 0x8023c1 <state+0x1>
      if (input_save[4*i+j] & 0x02) {
        volatile int i = 1;
        i+=1;
      }
      #endif
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
 9d4:	94 e0       	ldi	r25, 0x04	; 4
}

// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(void)
{
 9d6:	d9 01       	movw	r26, r18
 9d8:	80 e0       	ldi	r24, 0x00	; 0
/*****************************************************************************/
/* Private functions:                                                        */
/*****************************************************************************/
static uint8_t getSBoxValue(uint8_t num)
{
  return sbox[num];
 9da:	ec 91       	ld	r30, X
 9dc:	f0 e0       	ldi	r31, 0x00	; 0
 9de:	e5 5f       	subi	r30, 0xF5	; 245
 9e0:	fe 4d       	sbci	r31, 0xDE	; 222
 9e2:	40 81       	ld	r20, Z
      if (input_save[4*i+j] & 0x02) {
        volatile int i = 1;
        i+=1;
      }
      #endif
      (*state)[j][i] = getSBoxValue((*state)[j][i]);
 9e4:	4c 93       	st	X, r20
static void SubBytes(void)
{
  uint8_t i, j;
  for(i = 0; i < 4; ++i)
  {
    for(j = 0; j < 4; ++j)
 9e6:	8f 5f       	subi	r24, 0xFF	; 255
 9e8:	14 96       	adiw	r26, 0x04	; 4
 9ea:	84 30       	cpi	r24, 0x04	; 4
 9ec:	b1 f7       	brne	.-20     	; 0x9da <SubBytes+0xe>
 9ee:	91 50       	subi	r25, 0x01	; 1
 9f0:	2f 5f       	subi	r18, 0xFF	; 255
 9f2:	3f 4f       	sbci	r19, 0xFF	; 255
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void SubBytes(void)
{
  uint8_t i, j;
  for(i = 0; i < 4; ++i)
 9f4:	91 11       	cpse	r25, r1
 9f6:	ef cf       	rjmp	.-34     	; 0x9d6 <SubBytes+0xa>
 9f8:	08 95       	ret

000009fa <ShiftRows>:
        i += 1;
      }
      #endif
  #ifdef JITTER_2
  #endif
  temp           = (*state)[0][1];
 9fa:	e0 91 c0 23 	lds	r30, 0x23C0	; 0x8023c0 <state>
 9fe:	f0 91 c1 23 	lds	r31, 0x23C1	; 0x8023c1 <state+0x1>
 a02:	81 81       	ldd	r24, Z+1	; 0x01
  (*state)[0][1] = (*state)[1][1];
 a04:	95 81       	ldd	r25, Z+5	; 0x05
 a06:	91 83       	std	Z+1, r25	; 0x01
  (*state)[1][1] = (*state)[2][1];
 a08:	91 85       	ldd	r25, Z+9	; 0x09
 a0a:	95 83       	std	Z+5, r25	; 0x05
  (*state)[2][1] = (*state)[3][1];
 a0c:	95 85       	ldd	r25, Z+13	; 0x0d
 a0e:	91 87       	std	Z+9, r25	; 0x09
  (*state)[3][1] = temp;
 a10:	85 87       	std	Z+13, r24	; 0x0d
        i += 1;
      }
      #endif
  #ifdef JITTER_2
  #endif
  temp           = (*state)[0][2];
 a12:	82 81       	ldd	r24, Z+2	; 0x02
  (*state)[0][2] = (*state)[2][2];
 a14:	92 85       	ldd	r25, Z+10	; 0x0a
 a16:	92 83       	std	Z+2, r25	; 0x02
  (*state)[2][2] = temp;
 a18:	82 87       	std	Z+10, r24	; 0x0a
        volatile int i = 0;
        i += 1;
      }
      #endif

  temp       = (*state)[1][2];
 a1a:	86 81       	ldd	r24, Z+6	; 0x06
  (*state)[1][2] = (*state)[3][2];
 a1c:	96 85       	ldd	r25, Z+14	; 0x0e
 a1e:	96 83       	std	Z+6, r25	; 0x06
  (*state)[3][2] = temp;
 a20:	86 87       	std	Z+14, r24	; 0x0e
      }
      #endif
  #ifdef JITTER_2
  #endif
  // Rotate third row 3 columns to left
  temp       = (*state)[0][3];
 a22:	83 81       	ldd	r24, Z+3	; 0x03
  (*state)[0][3] = (*state)[3][3];
 a24:	97 85       	ldd	r25, Z+15	; 0x0f
 a26:	93 83       	std	Z+3, r25	; 0x03
  (*state)[3][3] = (*state)[2][3];
 a28:	93 85       	ldd	r25, Z+11	; 0x0b
 a2a:	97 87       	std	Z+15, r25	; 0x0f
  (*state)[2][3] = (*state)[1][3];
 a2c:	97 81       	ldd	r25, Z+7	; 0x07
 a2e:	93 87       	std	Z+11, r25	; 0x0b
  (*state)[1][3] = temp;
 a30:	87 83       	std	Z+7, r24	; 0x07
 a32:	08 95       	ret

00000a34 <xtime>:
}

static uint8_t xtime(uint8_t x)
{
  return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
 a34:	98 2f       	mov	r25, r24
 a36:	99 1f       	adc	r25, r25
 a38:	99 27       	eor	r25, r25
 a3a:	99 1f       	adc	r25, r25
 a3c:	2b e1       	ldi	r18, 0x1B	; 27
 a3e:	92 9f       	mul	r25, r18
 a40:	90 2d       	mov	r25, r0
 a42:	11 24       	eor	r1, r1
 a44:	88 0f       	add	r24, r24
}
 a46:	89 27       	eor	r24, r25
 a48:	08 95       	ret

00000a4a <InvSubBytes>:


// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(void)
{
 a4a:	20 91 c0 23 	lds	r18, 0x23C0	; 0x8023c0 <state>
 a4e:	30 91 c1 23 	lds	r19, 0x23C1	; 0x8023c1 <state+0x1>
  uint8_t i,j;
  for(i=0;i<4;++i)
  {
    for(j=0;j<4;++j)
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
 a52:	94 e0       	ldi	r25, 0x04	; 4


// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(void)
{
 a54:	d9 01       	movw	r26, r18
 a56:	80 e0       	ldi	r24, 0x00	; 0
  return sbox[num];
}

static uint8_t getSBoxInvert(uint8_t num)
{
  return rsbox[num];
 a58:	ec 91       	ld	r30, X
 a5a:	f0 e0       	ldi	r31, 0x00	; 0
 a5c:	e5 5f       	subi	r30, 0xF5	; 245
 a5e:	ff 4d       	sbci	r31, 0xDF	; 223
 a60:	40 81       	ld	r20, Z
  uint8_t i,j;
  for(i=0;i<4;++i)
  {
    for(j=0;j<4;++j)
    {
      (*state)[j][i] = getSBoxInvert((*state)[j][i]);
 a62:	4c 93       	st	X, r20
static void InvSubBytes(void)
{
  uint8_t i,j;
  for(i=0;i<4;++i)
  {
    for(j=0;j<4;++j)
 a64:	8f 5f       	subi	r24, 0xFF	; 255
 a66:	14 96       	adiw	r26, 0x04	; 4
 a68:	84 30       	cpi	r24, 0x04	; 4
 a6a:	b1 f7       	brne	.-20     	; 0xa58 <InvSubBytes+0xe>
 a6c:	91 50       	subi	r25, 0x01	; 1
 a6e:	2f 5f       	subi	r18, 0xFF	; 255
 a70:	3f 4f       	sbci	r19, 0xFF	; 255
// The SubBytes Function Substitutes the values in the
// state matrix with values in an S-box.
static void InvSubBytes(void)
{
  uint8_t i,j;
  for(i=0;i<4;++i)
 a72:	91 11       	cpse	r25, r1
 a74:	ef cf       	rjmp	.-34     	; 0xa54 <InvSubBytes+0xa>
 a76:	08 95       	ret

00000a78 <InvShiftRows>:
static void InvShiftRows(void)
{
  uint8_t temp;

  // Rotate first row 1 columns to right  
  temp=(*state)[3][1];
 a78:	e0 91 c0 23 	lds	r30, 0x23C0	; 0x8023c0 <state>
 a7c:	f0 91 c1 23 	lds	r31, 0x23C1	; 0x8023c1 <state+0x1>
 a80:	85 85       	ldd	r24, Z+13	; 0x0d
  (*state)[3][1]=(*state)[2][1];
 a82:	91 85       	ldd	r25, Z+9	; 0x09
 a84:	95 87       	std	Z+13, r25	; 0x0d
  (*state)[2][1]=(*state)[1][1];
 a86:	95 81       	ldd	r25, Z+5	; 0x05
 a88:	91 87       	std	Z+9, r25	; 0x09
  (*state)[1][1]=(*state)[0][1];
 a8a:	91 81       	ldd	r25, Z+1	; 0x01
 a8c:	95 83       	std	Z+5, r25	; 0x05
  (*state)[0][1]=temp;
 a8e:	81 83       	std	Z+1, r24	; 0x01

  // Rotate second row 2 columns to right 
  temp=(*state)[0][2];
 a90:	82 81       	ldd	r24, Z+2	; 0x02
  (*state)[0][2]=(*state)[2][2];
 a92:	92 85       	ldd	r25, Z+10	; 0x0a
 a94:	92 83       	std	Z+2, r25	; 0x02
  (*state)[2][2]=temp;
 a96:	82 87       	std	Z+10, r24	; 0x0a

  temp=(*state)[1][2];
 a98:	86 81       	ldd	r24, Z+6	; 0x06
  (*state)[1][2]=(*state)[3][2];
 a9a:	96 85       	ldd	r25, Z+14	; 0x0e
 a9c:	96 83       	std	Z+6, r25	; 0x06
  (*state)[3][2]=temp;
 a9e:	86 87       	std	Z+14, r24	; 0x0e

  // Rotate third row 3 columns to right
  temp=(*state)[0][3];
 aa0:	83 81       	ldd	r24, Z+3	; 0x03
  (*state)[0][3]=(*state)[1][3];
 aa2:	97 81       	ldd	r25, Z+7	; 0x07
 aa4:	93 83       	std	Z+3, r25	; 0x03
  (*state)[1][3]=(*state)[2][3];
 aa6:	93 85       	ldd	r25, Z+11	; 0x0b
 aa8:	97 83       	std	Z+7, r25	; 0x07
  (*state)[2][3]=(*state)[3][3];
 aaa:	97 85       	ldd	r25, Z+15	; 0x0f
 aac:	93 87       	std	Z+11, r25	; 0x0b
  (*state)[3][3]=temp;
 aae:	87 87       	std	Z+15, r24	; 0x0f
 ab0:	08 95       	ret

00000ab2 <Cipher>:
}


// Cipher is the main function that encrypts the PlainText.
static void Cipher(void)
{
 ab2:	9f 92       	push	r9
 ab4:	af 92       	push	r10
 ab6:	bf 92       	push	r11
 ab8:	cf 92       	push	r12
 aba:	df 92       	push	r13
 abc:	ef 92       	push	r14
 abe:	ff 92       	push	r15
 ac0:	0f 93       	push	r16
 ac2:	1f 93       	push	r17
 ac4:	cf 93       	push	r28
 ac6:	df 93       	push	r29
  uint8_t round = 0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(0); 
 ac8:	80 e0       	ldi	r24, 0x00	; 0
 aca:	0e 94 c2 04 	call	0x984	; 0x984 <AddRoundKey>
  
  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for(round = 1; round < Nr; ++round)
 ace:	bb 24       	eor	r11, r11
 ad0:	b3 94       	inc	r11
  {
    SubBytes();
 ad2:	0e 94 e6 04 	call	0x9cc	; 0x9cc <SubBytes>
    ShiftRows();
 ad6:	0e 94 fd 04 	call	0x9fa	; 0x9fa <ShiftRows>
      if (input_save[4*i] & 0x02) {
        volatile int i = 0;
        i += 1;
      }
      #endif
    t   = (*state)[i][0];
 ada:	c0 91 c0 23 	lds	r28, 0x23C0	; 0x8023c0 <state>
 ade:	d0 91 c1 23 	lds	r29, 0x23C1	; 0x8023c1 <state+0x1>
 ae2:	7e 01       	movw	r14, r28
 ae4:	80 e1       	ldi	r24, 0x10	; 16
 ae6:	e8 0e       	add	r14, r24
 ae8:	f1 1c       	adc	r15, r1
 aea:	a8 80       	ld	r10, Y
    Tmp = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3] ;
 aec:	09 81       	ldd	r16, Y+1	; 0x01
 aee:	8a 2d       	mov	r24, r10
 af0:	80 27       	eor	r24, r16
 af2:	1a 81       	ldd	r17, Y+2	; 0x02
 af4:	cb 80       	ldd	r12, Y+3	; 0x03
 af6:	91 2e       	mov	r9, r17
 af8:	9c 24       	eor	r9, r12
 afa:	d8 2e       	mov	r13, r24
 afc:	d9 24       	eor	r13, r9
    Tm  = (*state)[i][0] ^ (*state)[i][1] ; Tm = xtime(Tm);  (*state)[i][0] ^= Tm ^ Tmp ;
 afe:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 b02:	8a 25       	eor	r24, r10
 b04:	8d 25       	eor	r24, r13
 b06:	88 83       	st	Y, r24
    Tm  = (*state)[i][1] ^ (*state)[i][2] ; Tm = xtime(Tm);  (*state)[i][1] ^= Tm ^ Tmp ;
 b08:	80 2f       	mov	r24, r16
 b0a:	81 27       	eor	r24, r17
 b0c:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 b10:	80 27       	eor	r24, r16
 b12:	08 2f       	mov	r16, r24
 b14:	0d 25       	eor	r16, r13
 b16:	09 83       	std	Y+1, r16	; 0x01
    Tm  = (*state)[i][2] ^ (*state)[i][3] ; Tm = xtime(Tm);  (*state)[i][2] ^= Tm ^ Tmp ;
 b18:	89 2d       	mov	r24, r9
 b1a:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 b1e:	81 27       	eor	r24, r17
 b20:	18 2f       	mov	r17, r24
 b22:	1d 25       	eor	r17, r13
 b24:	1a 83       	std	Y+2, r17	; 0x02
    Tm  = (*state)[i][3] ^ t ;        Tm = xtime(Tm);  (*state)[i][3] ^= Tm ^ Tmp ;
 b26:	8a 2d       	mov	r24, r10
 b28:	8c 25       	eor	r24, r12
 b2a:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 b2e:	8c 25       	eor	r24, r12
 b30:	d8 26       	eor	r13, r24
 b32:	db 82       	std	Y+3, r13	; 0x03
 b34:	24 96       	adiw	r28, 0x04	; 4
// MixColumns function mixes the columns of the state matrix
static void MixColumns(void)
{
  uint8_t i;
  uint8_t Tmp,Tm,t;
  for(i = 0; i < 4; ++i)
 b36:	ce 15       	cp	r28, r14
 b38:	df 05       	cpc	r29, r15
 b3a:	b9 f6       	brne	.-82     	; 0xaea <Cipher+0x38>
  for(round = 1; round < Nr; ++round)
  {
    SubBytes();
    ShiftRows();
    MixColumns();
    AddRoundKey(round);
 b3c:	8b 2d       	mov	r24, r11
 b3e:	0e 94 c2 04 	call	0x984	; 0x984 <AddRoundKey>
  AddRoundKey(0); 
  
  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for(round = 1; round < Nr; ++round)
 b42:	b3 94       	inc	r11
 b44:	8a e0       	ldi	r24, 0x0A	; 10
 b46:	b8 12       	cpse	r11, r24
 b48:	c4 cf       	rjmp	.-120    	; 0xad2 <Cipher+0x20>
    AddRoundKey(round);
  }
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  SubBytes();
 b4a:	0e 94 e6 04 	call	0x9cc	; 0x9cc <SubBytes>
  ShiftRows();
 b4e:	0e 94 fd 04 	call	0x9fa	; 0x9fa <ShiftRows>
  AddRoundKey(Nr);
 b52:	8a e0       	ldi	r24, 0x0A	; 10
}
 b54:	df 91       	pop	r29
 b56:	cf 91       	pop	r28
 b58:	1f 91       	pop	r17
 b5a:	0f 91       	pop	r16
 b5c:	ff 90       	pop	r15
 b5e:	ef 90       	pop	r14
 b60:	df 90       	pop	r13
 b62:	cf 90       	pop	r12
 b64:	bf 90       	pop	r11
 b66:	af 90       	pop	r10
 b68:	9f 90       	pop	r9
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  SubBytes();
  ShiftRows();
  AddRoundKey(Nr);
 b6a:	0c 94 c2 04 	jmp	0x984	; 0x984 <AddRoundKey>

00000b6e <BlockCopy>:
  InvSubBytes();
  AddRoundKey(0);
}

static void BlockCopy(uint8_t* output, const uint8_t* input)
{
 b6e:	9b 01       	movw	r18, r22
 b70:	20 5f       	subi	r18, 0xF0	; 240
 b72:	3f 4f       	sbci	r19, 0xFF	; 255
  uint8_t i;
  for (i=0;i<KEYLEN;++i)
  {
    output[i] = input[i];
 b74:	fb 01       	movw	r30, r22
 b76:	41 91       	ld	r20, Z+
 b78:	bf 01       	movw	r22, r30
 b7a:	fc 01       	movw	r30, r24
 b7c:	41 93       	st	Z+, r20
 b7e:	cf 01       	movw	r24, r30
}

static void BlockCopy(uint8_t* output, const uint8_t* input)
{
  uint8_t i;
  for (i=0;i<KEYLEN;++i)
 b80:	62 17       	cp	r22, r18
 b82:	73 07       	cpc	r23, r19
 b84:	b9 f7       	brne	.-18     	; 0xb74 <BlockCopy+0x6>
  {
    output[i] = input[i];
  }
}
 b86:	08 95       	ret

00000b88 <AES128_ECB_indp_setkey>:
/* Public functions:                                                         */
/*****************************************************************************/

void AES128_ECB_indp_setkey(uint8_t* key)
{
  Key = key;
 b88:	80 93 fe 22 	sts	0x22FE, r24	; 0x8022fe <Key>
 b8c:	90 93 ff 22 	sts	0x22FF, r25	; 0x8022ff <Key+0x1>
  KeyExpansion();
 b90:	0c 94 1a 04 	jmp	0x834	; 0x834 <KeyExpansion>

00000b94 <AES128_ECB_indp_crypto>:
}

void AES128_ECB_indp_crypto(uint8_t* input)
{
  state = (state_t*)input;
 b94:	80 93 c0 23 	sts	0x23C0, r24	; 0x8023c0 <state>
 b98:	90 93 c1 23 	sts	0x23C1, r25	; 0x8023c1 <state+0x1>
  BlockCopy(input_save, input);
 b9c:	bc 01       	movw	r22, r24
 b9e:	80 e0       	ldi	r24, 0x00	; 0
 ba0:	93 e2       	ldi	r25, 0x23	; 35
 ba2:	0e 94 b7 05 	call	0xb6e	; 0xb6e <BlockCopy>
  Cipher();
 ba6:	0c 94 59 05 	jmp	0xab2	; 0xab2 <Cipher>

00000baa <AES128_ECB_encrypt>:
}

void AES128_ECB_encrypt(uint8_t* input, uint8_t* key, uint8_t* output)
{
 baa:	0f 93       	push	r16
 bac:	1f 93       	push	r17
 bae:	cf 93       	push	r28
 bb0:	df 93       	push	r29
 bb2:	8b 01       	movw	r16, r22
 bb4:	ea 01       	movw	r28, r20
  // Copy input to output, and work in-memory on output
  BlockCopy(output, input);
 bb6:	bc 01       	movw	r22, r24
 bb8:	ca 01       	movw	r24, r20
 bba:	0e 94 b7 05 	call	0xb6e	; 0xb6e <BlockCopy>
  state = (state_t*)output;
 bbe:	c0 93 c0 23 	sts	0x23C0, r28	; 0x8023c0 <state>
 bc2:	d0 93 c1 23 	sts	0x23C1, r29	; 0x8023c1 <state+0x1>

  Key = key;
 bc6:	00 93 fe 22 	sts	0x22FE, r16	; 0x8022fe <Key>
 bca:	10 93 ff 22 	sts	0x22FF, r17	; 0x8022ff <Key+0x1>
  KeyExpansion();
 bce:	0e 94 1a 04 	call	0x834	; 0x834 <KeyExpansion>

  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher();
}
 bd2:	df 91       	pop	r29
 bd4:	cf 91       	pop	r28
 bd6:	1f 91       	pop	r17
 bd8:	0f 91       	pop	r16

  Key = key;
  KeyExpansion();

  // The next function call encrypts the PlainText with the Key using AES algorithm.
  Cipher();
 bda:	0c 94 59 05 	jmp	0xab2	; 0xab2 <Cipher>

00000bde <AES128_ECB_decrypt>:
}

void AES128_ECB_decrypt(uint8_t* input, uint8_t* key, uint8_t *output)
{
 bde:	2f 92       	push	r2
 be0:	3f 92       	push	r3
 be2:	4f 92       	push	r4
 be4:	5f 92       	push	r5
 be6:	6f 92       	push	r6
 be8:	7f 92       	push	r7
 bea:	8f 92       	push	r8
 bec:	9f 92       	push	r9
 bee:	af 92       	push	r10
 bf0:	bf 92       	push	r11
 bf2:	cf 92       	push	r12
 bf4:	df 92       	push	r13
 bf6:	ef 92       	push	r14
 bf8:	ff 92       	push	r15
 bfa:	0f 93       	push	r16
 bfc:	1f 93       	push	r17
 bfe:	cf 93       	push	r28
 c00:	df 93       	push	r29
 c02:	00 d0       	rcall	.+0      	; 0xc04 <AES128_ECB_decrypt+0x26>
 c04:	00 d0       	rcall	.+0      	; 0xc06 <AES128_ECB_decrypt+0x28>
 c06:	cd b7       	in	r28, 0x3d	; 61
 c08:	de b7       	in	r29, 0x3e	; 62
 c0a:	6b 83       	std	Y+3, r22	; 0x03
 c0c:	7c 83       	std	Y+4, r23	; 0x04
 c0e:	5a 01       	movw	r10, r20
  // Copy input to output, and work in-memory on output
  BlockCopy(output, input);
 c10:	bc 01       	movw	r22, r24
 c12:	ca 01       	movw	r24, r20
 c14:	0e 94 b7 05 	call	0xb6e	; 0xb6e <BlockCopy>
  state = (state_t*)output;
 c18:	a0 92 c0 23 	sts	0x23C0, r10	; 0x8023c0 <state>
 c1c:	b0 92 c1 23 	sts	0x23C1, r11	; 0x8023c1 <state+0x1>

  // The KeyExpansion routine must be called before encryption.
  Key = key;
 c20:	8b 81       	ldd	r24, Y+3	; 0x03
 c22:	9c 81       	ldd	r25, Y+4	; 0x04
 c24:	80 93 fe 22 	sts	0x22FE, r24	; 0x8022fe <Key>
 c28:	90 93 ff 22 	sts	0x22FF, r25	; 0x8022ff <Key+0x1>
  KeyExpansion();
 c2c:	0e 94 1a 04 	call	0x834	; 0x834 <KeyExpansion>
static void InvCipher(void)
{
  uint8_t round=0;

  // Add the First round key to the state before starting the rounds.
  AddRoundKey(Nr); 
 c30:	8a e0       	ldi	r24, 0x0A	; 10
 c32:	0e 94 c2 04 	call	0x984	; 0x984 <AddRoundKey>

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for(round=Nr-1;round>0;round--)
 c36:	89 e0       	ldi	r24, 0x09	; 9
 c38:	38 2e       	mov	r3, r24
 c3a:	f5 01       	movw	r30, r10
 c3c:	70 96       	adiw	r30, 0x10	; 16
 c3e:	eb 83       	std	Y+3, r30	; 0x03
 c40:	fc 83       	std	Y+4, r31	; 0x04
  {
    InvShiftRows();
 c42:	0e 94 3c 05 	call	0xa78	; 0xa78 <InvShiftRows>
    InvSubBytes();
 c46:	0e 94 25 05 	call	0xa4a	; 0xa4a <InvSubBytes>
    AddRoundKey(round);
 c4a:	83 2d       	mov	r24, r3
 c4c:	0e 94 c2 04 	call	0x984	; 0x984 <AddRoundKey>
 c50:	85 01       	movw	r16, r10
{
  int i;
  uint8_t a,b,c,d;
  for(i=0;i<4;++i)
  { 
    a = (*state)[i][0];
 c52:	f8 01       	movw	r30, r16
 c54:	f0 81       	ld	r31, Z
 c56:	f9 83       	std	Y+1, r31	; 0x01
    b = (*state)[i][1];
 c58:	f8 01       	movw	r30, r16
 c5a:	f1 81       	ldd	r31, Z+1	; 0x01
 c5c:	fa 83       	std	Y+2, r31	; 0x02
    c = (*state)[i][2];
 c5e:	f8 01       	movw	r30, r16
 c60:	d2 80       	ldd	r13, Z+2	; 0x02
    d = (*state)[i][3];
 c62:	f3 80       	ldd	r15, Z+3	; 0x03

    (*state)[i][0] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
 c64:	89 81       	ldd	r24, Y+1	; 0x01
 c66:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c6a:	28 2e       	mov	r2, r24
 c6c:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c70:	e8 2e       	mov	r14, r24
 c72:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c76:	88 2e       	mov	r8, r24
 c78:	8a 81       	ldd	r24, Y+2	; 0x02
 c7a:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c7e:	8d 83       	std	Y+5, r24	; 0x05
 c80:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c84:	58 2e       	mov	r5, r24
 c86:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c8a:	98 2e       	mov	r9, r24
 c8c:	8d 2d       	mov	r24, r13
 c8e:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c92:	48 2e       	mov	r4, r24
 c94:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c98:	8e 83       	std	Y+6, r24	; 0x06
 c9a:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 c9e:	c8 2e       	mov	r12, r24
 ca0:	8f 2d       	mov	r24, r15
 ca2:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 ca6:	68 2e       	mov	r6, r24
 ca8:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 cac:	78 2e       	mov	r7, r24
 cae:	0e 94 1a 05 	call	0xa34	; 0xa34 <xtime>
 cb2:	92 2d       	mov	r25, r2
 cb4:	9e 25       	eor	r25, r14
 cb6:	98 25       	eor	r25, r8
 cb8:	fd 81       	ldd	r31, Y+5	; 0x05
 cba:	9f 27       	eor	r25, r31
 cbc:	99 25       	eor	r25, r9
 cbe:	2e 81       	ldd	r18, Y+6	; 0x06
 cc0:	92 27       	eor	r25, r18
 cc2:	9c 25       	eor	r25, r12
 cc4:	98 27       	eor	r25, r24
 cc6:	ea 81       	ldd	r30, Y+2	; 0x02
 cc8:	9e 27       	eor	r25, r30
 cca:	9d 25       	eor	r25, r13
 ccc:	9f 25       	eor	r25, r15
 cce:	f8 01       	movw	r30, r16
 cd0:	90 83       	st	Z, r25
    (*state)[i][1] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
 cd2:	9d 81       	ldd	r25, Y+5	; 0x05
 cd4:	98 25       	eor	r25, r8
 cd6:	95 25       	eor	r25, r5
 cd8:	99 25       	eor	r25, r9
 cda:	94 25       	eor	r25, r4
 cdc:	9c 25       	eor	r25, r12
 cde:	97 25       	eor	r25, r7
 ce0:	98 27       	eor	r25, r24
 ce2:	f9 81       	ldd	r31, Y+1	; 0x01
 ce4:	9f 27       	eor	r25, r31
 ce6:	9d 25       	eor	r25, r13
 ce8:	9f 25       	eor	r25, r15
 cea:	f8 01       	movw	r30, r16
 cec:	91 83       	std	Z+1, r25	; 0x01
 cee:	99 81       	ldd	r25, Y+1	; 0x01
 cf0:	fa 81       	ldd	r31, Y+2	; 0x02
 cf2:	9f 27       	eor	r25, r31
    (*state)[i][2] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
 cf4:	e8 24       	eor	r14, r8
 cf6:	e9 24       	eor	r14, r9
 cf8:	4e 24       	eor	r4, r14
 cfa:	24 25       	eor	r18, r4
 cfc:	2c 25       	eor	r18, r12
 cfe:	26 25       	eor	r18, r6
 d00:	28 27       	eor	r18, r24
 d02:	f2 26       	eor	r15, r18
 d04:	f9 26       	eor	r15, r25
 d06:	f8 01       	movw	r30, r16
 d08:	f2 82       	std	Z+2, r15	; 0x02
    (*state)[i][3] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
 d0a:	82 24       	eor	r8, r2
 d0c:	85 24       	eor	r8, r5
 d0e:	98 24       	eor	r9, r8
 d10:	c9 24       	eor	r12, r9
 d12:	c6 24       	eor	r12, r6
 d14:	7c 24       	eor	r7, r12
 d16:	87 25       	eor	r24, r7
 d18:	d8 26       	eor	r13, r24
 d1a:	d9 26       	eor	r13, r25
 d1c:	d3 82       	std	Z+3, r13	; 0x03
 d1e:	0c 5f       	subi	r16, 0xFC	; 252
 d20:	1f 4f       	sbci	r17, 0xFF	; 255
// Please use the references to gain more information.
static void InvMixColumns(void)
{
  int i;
  uint8_t a,b,c,d;
  for(i=0;i<4;++i)
 d22:	8b 81       	ldd	r24, Y+3	; 0x03
 d24:	9c 81       	ldd	r25, Y+4	; 0x04
 d26:	80 17       	cp	r24, r16
 d28:	91 07       	cpc	r25, r17
 d2a:	09 f0       	breq	.+2      	; 0xd2e <AES128_ECB_decrypt+0x150>
 d2c:	92 cf       	rjmp	.-220    	; 0xc52 <AES128_ECB_decrypt+0x74>
  AddRoundKey(Nr); 

  // There will be Nr rounds.
  // The first Nr-1 rounds are identical.
  // These Nr-1 rounds are executed in the loop below.
  for(round=Nr-1;round>0;round--)
 d2e:	3a 94       	dec	r3
 d30:	31 10       	cpse	r3, r1
 d32:	87 cf       	rjmp	.-242    	; 0xc42 <AES128_ECB_decrypt+0x64>
    InvMixColumns();
  }
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  InvShiftRows();
 d34:	0e 94 3c 05 	call	0xa78	; 0xa78 <InvShiftRows>
  InvSubBytes();
 d38:	0e 94 25 05 	call	0xa4a	; 0xa4a <InvSubBytes>
  AddRoundKey(0);
 d3c:	80 e0       	ldi	r24, 0x00	; 0
  // The KeyExpansion routine must be called before encryption.
  Key = key;
  KeyExpansion();

  InvCipher();
}
 d3e:	26 96       	adiw	r28, 0x06	; 6
 d40:	cd bf       	out	0x3d, r28	; 61
 d42:	de bf       	out	0x3e, r29	; 62
 d44:	df 91       	pop	r29
 d46:	cf 91       	pop	r28
 d48:	1f 91       	pop	r17
 d4a:	0f 91       	pop	r16
 d4c:	ff 90       	pop	r15
 d4e:	ef 90       	pop	r14
 d50:	df 90       	pop	r13
 d52:	cf 90       	pop	r12
 d54:	bf 90       	pop	r11
 d56:	af 90       	pop	r10
 d58:	9f 90       	pop	r9
 d5a:	8f 90       	pop	r8
 d5c:	7f 90       	pop	r7
 d5e:	6f 90       	pop	r6
 d60:	5f 90       	pop	r5
 d62:	4f 90       	pop	r4
 d64:	3f 90       	pop	r3
 d66:	2f 90       	pop	r2
  
  // The last round is given below.
  // The MixColumns function is not here in the last round.
  InvShiftRows();
  InvSubBytes();
  AddRoundKey(0);
 d68:	0c 94 c2 04 	jmp	0x984	; 0x984 <AddRoundKey>

00000d6c <aes_indep_init>:
#include "aes.h"

uint8_t enckey[16];

void aes_indep_init(void)
{
 d6c:	08 95       	ret

00000d6e <aes_indep_key>:
	;
}

void aes_indep_key(uint8_t * key)
{
    AES128_ECB_indp_setkey(key);
 d6e:	0c 94 c4 05 	jmp	0xb88	; 0xb88 <AES128_ECB_indp_setkey>

00000d72 <aes_indep_enc>:
}

void aes_indep_enc(uint8_t * pt)
{
	AES128_ECB_indp_crypto(pt);
 d72:	0c 94 ca 05 	jmp	0xb94	; 0xb94 <AES128_ECB_indp_crypto>

00000d76 <aes_indep_enc_pretrigger>:
 d76:	08 95       	ret

00000d78 <aes_indep_enc_posttrigger>:
{
    ;
}

void aes_indep_enc_posttrigger(uint8_t * pt)
{
 d78:	08 95       	ret

00000d7a <aes_indep_mask>:
    ;
}

void aes_indep_mask(uint8_t * m, uint8_t len)
{
 d7a:	08 95       	ret

00000d7c <main>:
    simpleserial_put('t', len, in);
    return 0x00;
}

int main(void){
    platform_init();
 d7c:	0e 94 04 04 	call	0x808	; 0x808 <platform_init>
    init_uart();
 d80:	0e 94 33 03 	call	0x666	; 0x666 <init_uart0>
    trigger_setup();
 d84:	81 e0       	ldi	r24, 0x01	; 1
 d86:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x7de601>
    simpleserial_init();
 d8a:	0e 94 c1 01 	call	0x382	; 0x382 <simpleserial_init>
    simpleserial_addcmd('k', 16, handle_key);
 d8e:	49 e1       	ldi	r20, 0x19	; 25
 d90:	51 e0       	ldi	r21, 0x01	; 1
 d92:	60 e1       	ldi	r22, 0x10	; 16
 d94:	70 e0       	ldi	r23, 0x00	; 0
 d96:	8b e6       	ldi	r24, 0x6B	; 107
 d98:	0e 94 be 01 	call	0x37c	; 0x37c <simpleserial_addcmd>
    simpleserial_addcmd('p', 16, handle_pt);
 d9c:	47 e2       	ldi	r20, 0x27	; 39
 d9e:	51 e0       	ldi	r21, 0x01	; 1
 da0:	60 e1       	ldi	r22, 0x10	; 16
 da2:	70 e0       	ldi	r23, 0x00	; 0
 da4:	80 e7       	ldi	r24, 0x70	; 112
 da6:	0e 94 be 01 	call	0x37c	; 0x37c <simpleserial_addcmd>
    simpleserial_addcmd('t', 0, handle_echo);
 daa:	43 e1       	ldi	r20, 0x13	; 19
 dac:	51 e0       	ldi	r21, 0x01	; 1
 dae:	60 e0       	ldi	r22, 0x00	; 0
 db0:	70 e0       	ldi	r23, 0x00	; 0
 db2:	84 e7       	ldi	r24, 0x74	; 116
 db4:	0e 94 be 01 	call	0x37c	; 0x37c <simpleserial_addcmd>

    while(1){
        simpleserial_get();
 db8:	0e 94 6e 02 	call	0x4dc	; 0x4dc <simpleserial_get>
 dbc:	fd cf       	rjmp	.-6      	; 0xdb8 <main+0x3c>

00000dbe <_exit>:
 dbe:	f8 94       	cli

00000dc0 <__stop_program>:
 dc0:	ff cf       	rjmp	.-2      	; 0xdc0 <__stop_program>
